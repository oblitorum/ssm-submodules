diff --color -urN a/vendor/cmp/cmp.go b/vendor/cmp/cmp.go
--- a/vendor/cmp/cmp.go	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/cmp/cmp.go	2024-01-07 22:37:18.282027619 +0800
@@ -0,0 +1,59 @@
+// Copyright 2023 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Package cmp provides types and functions related to comparing
+// ordered values.
+package cmp
+
+// Ordered is a constraint that permits any ordered type: any type
+// that supports the operators < <= >= >.
+// If future releases of Go add new ordered types,
+// this constraint will be modified to include them.
+//
+// Note that floating-point types may contain NaN ("not-a-number") values.
+// An operator such as == or < will always report false when
+// comparing a NaN value with any other value, NaN or not.
+// See the [Compare] function for a consistent way to compare NaN values.
+type Ordered interface {
+	~int | ~int8 | ~int16 | ~int32 | ~int64 |
+		~uint | ~uint8 | ~uint16 | ~uint32 | ~uint64 | ~uintptr |
+		~float32 | ~float64 |
+		~string
+}
+
+// Less reports whether x is less than y.
+// For floating-point types, a NaN is considered less than any non-NaN,
+// and -0.0 is not less than (is equal to) 0.0.
+func Less[T Ordered](x, y T) bool {
+	return (isNaN(x) && !isNaN(y)) || x < y
+}
+
+// Compare returns
+//
+//	-1 if x is less than y,
+//	 0 if x equals y,
+//	+1 if x is greater than y.
+//
+// For floating-point types, a NaN is considered less than any non-NaN,
+// a NaN is considered equal to a NaN, and -0.0 is equal to 0.0.
+func Compare[T Ordered](x, y T) int {
+	xNaN := isNaN(x)
+	yNaN := isNaN(y)
+	if xNaN && yNaN {
+		return 0
+	}
+	if xNaN || x < y {
+		return -1
+	}
+	if yNaN || x > y {
+		return +1
+	}
+	return 0
+}
+
+// isNaN reports whether x is a NaN without requiring the math package.
+// This will always return false if T is not floating-point.
+func isNaN[T Ordered](x T) bool {
+	return x != x
+}
diff --color -urN a/vendor/cmp/cmp_test.go b/vendor/cmp/cmp_test.go
--- a/vendor/cmp/cmp_test.go	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/cmp/cmp_test.go	2024-01-07 22:37:18.292027622 +0800
@@ -0,0 +1,95 @@
+// Copyright 2023 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package cmp_test
+
+import (
+	"cmp"
+	"math"
+	"sort"
+	"testing"
+)
+
+var negzero = math.Copysign(0, -1)
+
+var tests = []struct {
+	x, y    any
+	compare int
+}{
+	{1, 2, -1},
+	{1, 1, 0},
+	{2, 1, +1},
+	{"a", "aa", -1},
+	{"a", "a", 0},
+	{"aa", "a", +1},
+	{1.0, 1.1, -1},
+	{1.1, 1.1, 0},
+	{1.1, 1.0, +1},
+	{math.Inf(1), math.Inf(1), 0},
+	{math.Inf(-1), math.Inf(-1), 0},
+	{math.Inf(-1), 1.0, -1},
+	{1.0, math.Inf(-1), +1},
+	{math.Inf(1), 1.0, +1},
+	{1.0, math.Inf(1), -1},
+	{math.NaN(), math.NaN(), 0},
+	{0.0, math.NaN(), +1},
+	{math.NaN(), 0.0, -1},
+	{math.NaN(), math.Inf(-1), -1},
+	{math.Inf(-1), math.NaN(), +1},
+	{0.0, 0.0, 0},
+	{negzero, negzero, 0},
+	{negzero, 0.0, 0},
+	{0.0, negzero, 0},
+	{negzero, 1.0, -1},
+	{negzero, -1.0, +1},
+}
+
+func TestLess(t *testing.T) {
+	for _, test := range tests {
+		var b bool
+		switch test.x.(type) {
+		case int:
+			b = cmp.Less(test.x.(int), test.y.(int))
+		case string:
+			b = cmp.Less(test.x.(string), test.y.(string))
+		case float64:
+			b = cmp.Less(test.x.(float64), test.y.(float64))
+		}
+		if b != (test.compare < 0) {
+			t.Errorf("Less(%v, %v) == %t, want %t", test.x, test.y, b, test.compare < 0)
+		}
+	}
+}
+
+func TestCompare(t *testing.T) {
+	for _, test := range tests {
+		var c int
+		switch test.x.(type) {
+		case int:
+			c = cmp.Compare(test.x.(int), test.y.(int))
+		case string:
+			c = cmp.Compare(test.x.(string), test.y.(string))
+		case float64:
+			c = cmp.Compare(test.x.(float64), test.y.(float64))
+		}
+		if c != test.compare {
+			t.Errorf("Compare(%v, %v) == %d, want %d", test.x, test.y, c, test.compare)
+		}
+	}
+}
+
+func TestSort(t *testing.T) {
+	// Test that our comparison function is consistent with
+	// sort.Float64s.
+	input := []float64{1.0, 0.0, negzero, math.Inf(1), math.Inf(-1), math.NaN()}
+	sort.Float64s(input)
+	for i := 0; i < len(input)-1; i++ {
+		if cmp.Less(input[i+1], input[i]) {
+			t.Errorf("Less sort mismatch at %d in %v", i, input)
+		}
+		if cmp.Compare(input[i], input[i+1]) > 0 {
+			t.Errorf("Compare sort mismatch at %d in %v", i, input)
+		}
+	}
+}
diff --color -urN a/vendor/maps/example_test.go b/vendor/maps/example_test.go
--- a/vendor/maps/example_test.go	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/maps/example_test.go	2024-01-07 22:37:30.822073792 +0800
@@ -0,0 +1,45 @@
+// Copyright 2023 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package maps_test
+
+import (
+	"fmt"
+	"maps"
+	"strings"
+)
+
+func ExampleDeleteFunc() {
+	m := map[string]int{
+		"one":   1,
+		"two":   2,
+		"three": 3,
+		"four":  4,
+	}
+	maps.DeleteFunc(m, func(k string, v int) bool {
+		return v%2 != 0 // delete odd values
+	})
+	fmt.Println(m)
+	// Output:
+	// map[four:4 two:2]
+}
+
+func ExampleEqualFunc() {
+	m1 := map[int]string{
+		1:    "one",
+		10:   "Ten",
+		1000: "THOUSAND",
+	}
+	m2 := map[int][]byte{
+		1:    []byte("One"),
+		10:   []byte("Ten"),
+		1000: []byte("Thousand"),
+	}
+	eq := maps.EqualFunc(m1, m2, func(v1 string, v2 []byte) bool {
+		return strings.ToLower(v1) == strings.ToLower(string(v2))
+	})
+	fmt.Println(eq)
+	// Output:
+	// true
+}
diff --color -urN a/vendor/maps/maps.go b/vendor/maps/maps.go
--- a/vendor/maps/maps.go	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/maps/maps.go	2024-01-07 22:37:30.822073792 +0800
@@ -0,0 +1,66 @@
+// Copyright 2021 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Package maps defines various functions useful with maps of any type.
+package maps
+
+// Equal reports whether two maps contain the same key/value pairs.
+// Values are compared using ==.
+func Equal[M1, M2 ~map[K]V, K, V comparable](m1 M1, m2 M2) bool {
+	if len(m1) != len(m2) {
+		return false
+	}
+	for k, v1 := range m1 {
+		if v2, ok := m2[k]; !ok || v1 != v2 {
+			return false
+		}
+	}
+	return true
+}
+
+// EqualFunc is like Equal, but compares values using eq.
+// Keys are still compared with ==.
+func EqualFunc[M1 ~map[K]V1, M2 ~map[K]V2, K comparable, V1, V2 any](m1 M1, m2 M2, eq func(V1, V2) bool) bool {
+	if len(m1) != len(m2) {
+		return false
+	}
+	for k, v1 := range m1 {
+		if v2, ok := m2[k]; !ok || !eq(v1, v2) {
+			return false
+		}
+	}
+	return true
+}
+
+// clone is implemented in the runtime package.
+func clone(m any) any
+
+// Clone returns a copy of m.  This is a shallow clone:
+// the new keys and values are set using ordinary assignment.
+func Clone[M ~map[K]V, K comparable, V any](m M) M {
+	// Preserve nil in case it matters.
+	if m == nil {
+		return nil
+	}
+	return clone(m).(M)
+}
+
+// Copy copies all key/value pairs in src adding them to dst.
+// When a key in src is already present in dst,
+// the value in dst will be overwritten by the value associated
+// with the key in src.
+func Copy[M1 ~map[K]V, M2 ~map[K]V, K comparable, V any](dst M1, src M2) {
+	for k, v := range src {
+		dst[k] = v
+	}
+}
+
+// DeleteFunc deletes any key/value pairs from m for which del returns true.
+func DeleteFunc[M ~map[K]V, K comparable, V any](m M, del func(K, V) bool) {
+	for k, v := range m {
+		if del(k, v) {
+			delete(m, k)
+		}
+	}
+}
diff --color -urN a/vendor/maps/maps.s b/vendor/maps/maps.s
--- a/vendor/maps/maps.s	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/maps/maps.s	2024-01-07 22:37:30.822073792 +0800
@@ -0,0 +1,5 @@
+// Copyright 2023 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// need this empty asm file to enable linkname.
\ No newline at end of file
diff --color -urN a/vendor/maps/maps_test.go b/vendor/maps/maps_test.go
--- a/vendor/maps/maps_test.go	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/maps/maps_test.go	2024-01-07 22:37:30.822073792 +0800
@@ -0,0 +1,184 @@
+// Copyright 2021 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package maps
+
+import (
+	"math"
+	"strconv"
+	"testing"
+)
+
+var m1 = map[int]int{1: 2, 2: 4, 4: 8, 8: 16}
+var m2 = map[int]string{1: "2", 2: "4", 4: "8", 8: "16"}
+
+func TestEqual(t *testing.T) {
+	if !Equal(m1, m1) {
+		t.Errorf("Equal(%v, %v) = false, want true", m1, m1)
+	}
+	if Equal(m1, (map[int]int)(nil)) {
+		t.Errorf("Equal(%v, nil) = true, want false", m1)
+	}
+	if Equal((map[int]int)(nil), m1) {
+		t.Errorf("Equal(nil, %v) = true, want false", m1)
+	}
+	if !Equal[map[int]int, map[int]int](nil, nil) {
+		t.Error("Equal(nil, nil) = false, want true")
+	}
+	if ms := map[int]int{1: 2}; Equal(m1, ms) {
+		t.Errorf("Equal(%v, %v) = true, want false", m1, ms)
+	}
+
+	// Comparing NaN for equality is expected to fail.
+	mf := map[int]float64{1: 0, 2: math.NaN()}
+	if Equal(mf, mf) {
+		t.Errorf("Equal(%v, %v) = true, want false", mf, mf)
+	}
+}
+
+// equal is simply ==.
+func equal[T comparable](v1, v2 T) bool {
+	return v1 == v2
+}
+
+// equalNaN is like == except that all NaNs are equal.
+func equalNaN[T comparable](v1, v2 T) bool {
+	isNaN := func(f T) bool { return f != f }
+	return v1 == v2 || (isNaN(v1) && isNaN(v2))
+}
+
+// equalStr compares ints and strings.
+func equalIntStr(v1 int, v2 string) bool {
+	return strconv.Itoa(v1) == v2
+}
+
+func TestEqualFunc(t *testing.T) {
+	if !EqualFunc(m1, m1, equal[int]) {
+		t.Errorf("EqualFunc(%v, %v, equal) = false, want true", m1, m1)
+	}
+	if EqualFunc(m1, (map[int]int)(nil), equal[int]) {
+		t.Errorf("EqualFunc(%v, nil, equal) = true, want false", m1)
+	}
+	if EqualFunc((map[int]int)(nil), m1, equal[int]) {
+		t.Errorf("EqualFunc(nil, %v, equal) = true, want false", m1)
+	}
+	if !EqualFunc[map[int]int, map[int]int](nil, nil, equal[int]) {
+		t.Error("EqualFunc(nil, nil, equal) = false, want true")
+	}
+	if ms := map[int]int{1: 2}; EqualFunc(m1, ms, equal[int]) {
+		t.Errorf("EqualFunc(%v, %v, equal) = true, want false", m1, ms)
+	}
+
+	// Comparing NaN for equality is expected to fail.
+	mf := map[int]float64{1: 0, 2: math.NaN()}
+	if EqualFunc(mf, mf, equal[float64]) {
+		t.Errorf("EqualFunc(%v, %v, equal) = true, want false", mf, mf)
+	}
+	// But it should succeed using equalNaN.
+	if !EqualFunc(mf, mf, equalNaN[float64]) {
+		t.Errorf("EqualFunc(%v, %v, equalNaN) = false, want true", mf, mf)
+	}
+
+	if !EqualFunc(m1, m2, equalIntStr) {
+		t.Errorf("EqualFunc(%v, %v, equalIntStr) = false, want true", m1, m2)
+	}
+}
+
+func TestClone(t *testing.T) {
+	mc := Clone(m1)
+	if !Equal(mc, m1) {
+		t.Errorf("Clone(%v) = %v, want %v", m1, mc, m1)
+	}
+	mc[16] = 32
+	if Equal(mc, m1) {
+		t.Errorf("Equal(%v, %v) = true, want false", mc, m1)
+	}
+}
+
+func TestCloneNil(t *testing.T) {
+	var m1 map[string]int
+	mc := Clone(m1)
+	if mc != nil {
+		t.Errorf("Clone(%v) = %v, want %v", m1, mc, m1)
+	}
+}
+
+func TestCopy(t *testing.T) {
+	mc := Clone(m1)
+	Copy(mc, mc)
+	if !Equal(mc, m1) {
+		t.Errorf("Copy(%v, %v) = %v, want %v", m1, m1, mc, m1)
+	}
+	Copy(mc, map[int]int{16: 32})
+	want := map[int]int{1: 2, 2: 4, 4: 8, 8: 16, 16: 32}
+	if !Equal(mc, want) {
+		t.Errorf("Copy result = %v, want %v", mc, want)
+	}
+
+	type M1 map[int]bool
+	type M2 map[int]bool
+	Copy(make(M1), make(M2))
+}
+
+func TestDeleteFunc(t *testing.T) {
+	mc := Clone(m1)
+	DeleteFunc(mc, func(int, int) bool { return false })
+	if !Equal(mc, m1) {
+		t.Errorf("DeleteFunc(%v, true) = %v, want %v", m1, mc, m1)
+	}
+	DeleteFunc(mc, func(k, v int) bool { return k > 3 })
+	want := map[int]int{1: 2, 2: 4}
+	if !Equal(mc, want) {
+		t.Errorf("DeleteFunc result = %v, want %v", mc, want)
+	}
+}
+
+var n map[int]int
+
+func BenchmarkMapClone(b *testing.B) {
+	var m = make(map[int]int)
+	for i := 0; i < 1000000; i++ {
+		m[i] = i
+	}
+	b.ResetTimer()
+	for i := 0; i < b.N; i++ {
+		n = Clone(m)
+	}
+}
+
+func TestCloneWithDelete(t *testing.T) {
+	var m = make(map[int]int)
+	for i := 0; i < 32; i++ {
+		m[i] = i
+	}
+	for i := 8; i < 32; i++ {
+		delete(m, i)
+	}
+	m2 := Clone(m)
+	if len(m2) != 8 {
+		t.Errorf("len2(m2) = %d, want %d", len(m2), 8)
+	}
+	for i := 0; i < 8; i++ {
+		if m2[i] != m[i] {
+			t.Errorf("m2[%d] = %d, want %d", i, m2[i], m[i])
+		}
+	}
+}
+
+func TestCloneWithMapAssign(t *testing.T) {
+	var m = make(map[int]int)
+	const N = 25
+	for i := 0; i < N; i++ {
+		m[i] = i
+	}
+	m2 := Clone(m)
+	if len(m2) != N {
+		t.Errorf("len2(m2) = %d, want %d", len(m2), N)
+	}
+	for i := 0; i < N; i++ {
+		if m2[i] != m[i] {
+			t.Errorf("m2[%d] = %d, want %d", i, m2[i], m[i])
+		}
+	}
+}
diff --color -urN a/vendor/slices/example_test.go b/vendor/slices/example_test.go
--- a/vendor/slices/example_test.go	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/slices/example_test.go	2024-01-07 22:37:23.162035574 +0800
@@ -0,0 +1,322 @@
+// Copyright 2023 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package slices_test
+
+import (
+	"cmp"
+	"fmt"
+	"slices"
+	"strconv"
+	"strings"
+)
+
+func ExampleBinarySearch() {
+	names := []string{"Alice", "Bob", "Vera"}
+	n, found := slices.BinarySearch(names, "Vera")
+	fmt.Println("Vera:", n, found)
+	n, found = slices.BinarySearch(names, "Bill")
+	fmt.Println("Bill:", n, found)
+	// Output:
+	// Vera: 2 true
+	// Bill: 1 false
+}
+
+func ExampleBinarySearchFunc() {
+	type Person struct {
+		Name string
+		Age  int
+	}
+	people := []Person{
+		{"Alice", 55},
+		{"Bob", 24},
+		{"Gopher", 13},
+	}
+	n, found := slices.BinarySearchFunc(people, Person{"Bob", 0}, func(a, b Person) int {
+		return cmp.Compare(a.Name, b.Name)
+	})
+	fmt.Println("Bob:", n, found)
+	// Output:
+	// Bob: 1 true
+}
+
+func ExampleCompact() {
+	seq := []int{0, 1, 1, 2, 3, 5, 8}
+	seq = slices.Compact(seq)
+	fmt.Println(seq)
+	// Output:
+	// [0 1 2 3 5 8]
+}
+
+func ExampleCompactFunc() {
+	names := []string{"bob", "Bob", "alice", "Vera", "VERA"}
+	names = slices.CompactFunc(names, func(a, b string) bool {
+		return strings.ToLower(a) == strings.ToLower(b)
+	})
+	fmt.Println(names)
+	// Output:
+	// [bob alice Vera]
+}
+
+func ExampleCompare() {
+	names := []string{"Alice", "Bob", "Vera"}
+	fmt.Println("Equal:", slices.Compare(names, []string{"Alice", "Bob", "Vera"}))
+	fmt.Println("V < X:", slices.Compare(names, []string{"Alice", "Bob", "Xena"}))
+	fmt.Println("V > C:", slices.Compare(names, []string{"Alice", "Bob", "Cat"}))
+	fmt.Println("3 > 2:", slices.Compare(names, []string{"Alice", "Bob"}))
+	// Output:
+	// Equal: 0
+	// V < X: -1
+	// V > C: 1
+	// 3 > 2: 1
+}
+
+func ExampleCompareFunc() {
+	numbers := []int{0, 43, 8}
+	strings := []string{"0", "0", "8"}
+	result := slices.CompareFunc(numbers, strings, func(n int, s string) int {
+		sn, err := strconv.Atoi(s)
+		if err != nil {
+			return 1
+		}
+		return cmp.Compare(n, sn)
+	})
+	fmt.Println(result)
+	// Output:
+	// 1
+}
+
+func ExampleContainsFunc() {
+	numbers := []int{0, 42, -10, 8}
+	hasNegative := slices.ContainsFunc(numbers, func(n int) bool {
+		return n < 0
+	})
+	fmt.Println("Has a negative:", hasNegative)
+	hasOdd := slices.ContainsFunc(numbers, func(n int) bool {
+		return n%2 != 0
+	})
+	fmt.Println("Has an odd number:", hasOdd)
+	// Output:
+	// Has a negative: true
+	// Has an odd number: false
+}
+
+func ExampleDelete() {
+	letters := []string{"a", "b", "c", "d", "e"}
+	letters = slices.Delete(letters, 1, 4)
+	fmt.Println(letters)
+	// Output:
+	// [a e]
+}
+
+func ExampleDeleteFunc() {
+	seq := []int{0, 1, 1, 2, 3, 5, 8}
+	seq = slices.DeleteFunc(seq, func(n int) bool {
+		return n%2 != 0 // delete the odd numbers
+	})
+	fmt.Println(seq)
+	// Output:
+	// [0 2 8]
+}
+
+func ExampleEqual() {
+	numbers := []int{0, 42, 8}
+	fmt.Println(slices.Equal(numbers, []int{0, 42, 8}))
+	fmt.Println(slices.Equal(numbers, []int{10}))
+	// Output:
+	// true
+	// false
+}
+
+func ExampleEqualFunc() {
+	numbers := []int{0, 42, 8}
+	strings := []string{"000", "42", "0o10"}
+	equal := slices.EqualFunc(numbers, strings, func(n int, s string) bool {
+		sn, err := strconv.ParseInt(s, 0, 64)
+		if err != nil {
+			return false
+		}
+		return n == int(sn)
+	})
+	fmt.Println(equal)
+	// Output:
+	// true
+}
+
+func ExampleIndex() {
+	numbers := []int{0, 42, 8}
+	fmt.Println(slices.Index(numbers, 8))
+	fmt.Println(slices.Index(numbers, 7))
+	// Output:
+	// 2
+	// -1
+}
+
+func ExampleIndexFunc() {
+	numbers := []int{0, 42, -10, 8}
+	i := slices.IndexFunc(numbers, func(n int) bool {
+		return n < 0
+	})
+	fmt.Println("First negative at index", i)
+	// Output:
+	// First negative at index 2
+}
+
+func ExampleInsert() {
+	names := []string{"Alice", "Bob", "Vera"}
+	names = slices.Insert(names, 1, "Bill", "Billie")
+	names = slices.Insert(names, len(names), "Zac")
+	fmt.Println(names)
+	// Output:
+	// [Alice Bill Billie Bob Vera Zac]
+}
+
+func ExampleIsSorted() {
+	fmt.Println(slices.IsSorted([]string{"Alice", "Bob", "Vera"}))
+	fmt.Println(slices.IsSorted([]int{0, 2, 1}))
+	// Output:
+	// true
+	// false
+}
+
+func ExampleIsSortedFunc() {
+	names := []string{"alice", "Bob", "VERA"}
+	isSortedInsensitive := slices.IsSortedFunc(names, func(a, b string) int {
+		return cmp.Compare(strings.ToLower(a), strings.ToLower(b))
+	})
+	fmt.Println(isSortedInsensitive)
+	fmt.Println(slices.IsSorted(names))
+	// Output:
+	// true
+	// false
+}
+
+func ExampleMax() {
+	numbers := []int{0, 42, -10, 8}
+	fmt.Println(slices.Max(numbers))
+	// Output:
+	// 42
+}
+
+func ExampleMaxFunc() {
+	type Person struct {
+		Name string
+		Age  int
+	}
+	people := []Person{
+		{"Gopher", 13},
+		{"Alice", 55},
+		{"Vera", 24},
+		{"Bob", 55},
+	}
+	firstOldest := slices.MaxFunc(people, func(a, b Person) int {
+		return cmp.Compare(a.Age, b.Age)
+	})
+	fmt.Println(firstOldest.Name)
+	// Output:
+	// Alice
+}
+
+func ExampleMin() {
+	numbers := []int{0, 42, -10, 8}
+	fmt.Println(slices.Min(numbers))
+	// Output:
+	// -10
+}
+
+func ExampleMinFunc() {
+	type Person struct {
+		Name string
+		Age  int
+	}
+	people := []Person{
+		{"Gopher", 13},
+		{"Bob", 5},
+		{"Vera", 24},
+		{"Bill", 5},
+	}
+	firstYoungest := slices.MinFunc(people, func(a, b Person) int {
+		return cmp.Compare(a.Age, b.Age)
+	})
+	fmt.Println(firstYoungest.Name)
+	// Output:
+	// Bob
+}
+
+func ExampleReplace() {
+	names := []string{"Alice", "Bob", "Vera", "Zac"}
+	names = slices.Replace(names, 1, 3, "Bill", "Billie", "Cat")
+	fmt.Println(names)
+	// Output:
+	// [Alice Bill Billie Cat Zac]
+}
+
+func ExampleReverse() {
+	names := []string{"alice", "Bob", "VERA"}
+	slices.Reverse(names)
+	fmt.Println(names)
+	// Output:
+	// [VERA Bob alice]
+}
+
+func ExampleSort() {
+	smallInts := []int8{0, 42, -10, 8}
+	slices.Sort(smallInts)
+	fmt.Println(smallInts)
+	// Output:
+	// [-10 0 8 42]
+}
+
+func ExampleSortFunc_caseInsensitive() {
+	names := []string{"Bob", "alice", "VERA"}
+	slices.SortFunc(names, func(a, b string) int {
+		return cmp.Compare(strings.ToLower(a), strings.ToLower(b))
+	})
+	fmt.Println(names)
+	// Output:
+	// [alice Bob VERA]
+}
+
+func ExampleSortFunc_multiField() {
+	type Person struct {
+		Name string
+		Age  int
+	}
+	people := []Person{
+		{"Gopher", 13},
+		{"Alice", 55},
+		{"Bob", 24},
+		{"Alice", 20},
+	}
+	slices.SortFunc(people, func(a, b Person) int {
+		if n := cmp.Compare(a.Name, b.Name); n != 0 {
+			return n
+		}
+		// If names are equal, order by age
+		return cmp.Compare(a.Age, b.Age)
+	})
+	fmt.Println(people)
+	// Output:
+	// [{Alice 20} {Alice 55} {Bob 24} {Gopher 13}]
+}
+
+func ExampleSortStableFunc() {
+	type Person struct {
+		Name string
+		Age  int
+	}
+	people := []Person{
+		{"Gopher", 13},
+		{"Alice", 20},
+		{"Bob", 24},
+		{"Alice", 55},
+	}
+	// Stable sort by name, keeping age ordering of Alices intact
+	slices.SortStableFunc(people, func(a, b Person) int {
+		return cmp.Compare(a.Name, b.Name)
+	})
+	fmt.Println(people)
+	// Output:
+	// [{Alice 20} {Alice 55} {Bob 24} {Gopher 13}]
+}
diff --color -urN a/vendor/slices/slices.go b/vendor/slices/slices.go
--- a/vendor/slices/slices.go	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/slices/slices.go	2024-01-07 22:37:23.162035574 +0800
@@ -0,0 +1,498 @@
+// Copyright 2021 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+// Package slices defines various functions useful with slices of any type.
+package slices
+
+import (
+	"cmp"
+	"unsafe"
+)
+
+// Equal reports whether two slices are equal: the same length and all
+// elements equal. If the lengths are different, Equal returns false.
+// Otherwise, the elements are compared in increasing index order, and the
+// comparison stops at the first unequal pair.
+// Floating point NaNs are not considered equal.
+func Equal[S ~[]E, E comparable](s1, s2 S) bool {
+	if len(s1) != len(s2) {
+		return false
+	}
+	for i := range s1 {
+		if s1[i] != s2[i] {
+			return false
+		}
+	}
+	return true
+}
+
+// EqualFunc reports whether two slices are equal using an equality
+// function on each pair of elements. If the lengths are different,
+// EqualFunc returns false. Otherwise, the elements are compared in
+// increasing index order, and the comparison stops at the first index
+// for which eq returns false.
+func EqualFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, eq func(E1, E2) bool) bool {
+	if len(s1) != len(s2) {
+		return false
+	}
+	for i, v1 := range s1 {
+		v2 := s2[i]
+		if !eq(v1, v2) {
+			return false
+		}
+	}
+	return true
+}
+
+// Compare compares the elements of s1 and s2, using [cmp.Compare] on each pair
+// of elements. The elements are compared sequentially, starting at index 0,
+// until one element is not equal to the other.
+// The result of comparing the first non-matching elements is returned.
+// If both slices are equal until one of them ends, the shorter slice is
+// considered less than the longer one.
+// The result is 0 if s1 == s2, -1 if s1 < s2, and +1 if s1 > s2.
+func Compare[S ~[]E, E cmp.Ordered](s1, s2 S) int {
+	for i, v1 := range s1 {
+		if i >= len(s2) {
+			return +1
+		}
+		v2 := s2[i]
+		if c := cmp.Compare(v1, v2); c != 0 {
+			return c
+		}
+	}
+	if len(s1) < len(s2) {
+		return -1
+	}
+	return 0
+}
+
+// CompareFunc is like [Compare] but uses a custom comparison function on each
+// pair of elements.
+// The result is the first non-zero result of cmp; if cmp always
+// returns 0 the result is 0 if len(s1) == len(s2), -1 if len(s1) < len(s2),
+// and +1 if len(s1) > len(s2).
+func CompareFunc[S1 ~[]E1, S2 ~[]E2, E1, E2 any](s1 S1, s2 S2, cmp func(E1, E2) int) int {
+	for i, v1 := range s1 {
+		if i >= len(s2) {
+			return +1
+		}
+		v2 := s2[i]
+		if c := cmp(v1, v2); c != 0 {
+			return c
+		}
+	}
+	if len(s1) < len(s2) {
+		return -1
+	}
+	return 0
+}
+
+// Index returns the index of the first occurrence of v in s,
+// or -1 if not present.
+func Index[S ~[]E, E comparable](s S, v E) int {
+	for i := range s {
+		if v == s[i] {
+			return i
+		}
+	}
+	return -1
+}
+
+// IndexFunc returns the first index i satisfying f(s[i]),
+// or -1 if none do.
+func IndexFunc[S ~[]E, E any](s S, f func(E) bool) int {
+	for i := range s {
+		if f(s[i]) {
+			return i
+		}
+	}
+	return -1
+}
+
+// Contains reports whether v is present in s.
+func Contains[S ~[]E, E comparable](s S, v E) bool {
+	return Index(s, v) >= 0
+}
+
+// ContainsFunc reports whether at least one
+// element e of s satisfies f(e).
+func ContainsFunc[S ~[]E, E any](s S, f func(E) bool) bool {
+	return IndexFunc(s, f) >= 0
+}
+
+// Insert inserts the values v... into s at index i,
+// returning the modified slice.
+// The elements at s[i:] are shifted up to make room.
+// In the returned slice r, r[i] == v[0],
+// and r[i+len(v)] == value originally at r[i].
+// Insert panics if i is out of range.
+// This function is O(len(s) + len(v)).
+func Insert[S ~[]E, E any](s S, i int, v ...E) S {
+	m := len(v)
+	if m == 0 {
+		return s
+	}
+	n := len(s)
+	if i == n {
+		return append(s, v...)
+	}
+	if n+m > cap(s) {
+		// Use append rather than make so that we bump the size of
+		// the slice up to the next storage class.
+		// This is what Grow does but we don't call Grow because
+		// that might copy the values twice.
+		s2 := append(s[:i], make(S, n+m-i)...)
+		copy(s2[i:], v)
+		copy(s2[i+m:], s[i:])
+		return s2
+	}
+	s = s[:n+m]
+
+	// before:
+	// s: aaaaaaaabbbbccccccccdddd
+	//            ^   ^       ^   ^
+	//            i  i+m      n  n+m
+	// after:
+	// s: aaaaaaaavvvvbbbbcccccccc
+	//            ^   ^       ^   ^
+	//            i  i+m      n  n+m
+	//
+	// a are the values that don't move in s.
+	// v are the values copied in from v.
+	// b and c are the values from s that are shifted up in index.
+	// d are the values that get overwritten, never to be seen again.
+
+	if !overlaps(v, s[i+m:]) {
+		// Easy case - v does not overlap either the c or d regions.
+		// (It might be in some of a or b, or elsewhere entirely.)
+		// The data we copy up doesn't write to v at all, so just do it.
+
+		copy(s[i+m:], s[i:])
+
+		// Now we have
+		// s: aaaaaaaabbbbbbbbcccccccc
+		//            ^   ^       ^   ^
+		//            i  i+m      n  n+m
+		// Note the b values are duplicated.
+
+		copy(s[i:], v)
+
+		// Now we have
+		// s: aaaaaaaavvvvbbbbcccccccc
+		//            ^   ^       ^   ^
+		//            i  i+m      n  n+m
+		// That's the result we want.
+		return s
+	}
+
+	// The hard case - v overlaps c or d. We can't just shift up
+	// the data because we'd move or clobber the values we're trying
+	// to insert.
+	// So instead, write v on top of d, then rotate.
+	copy(s[n:], v)
+
+	// Now we have
+	// s: aaaaaaaabbbbccccccccvvvv
+	//            ^   ^       ^   ^
+	//            i  i+m      n  n+m
+
+	rotateRight(s[i:], m)
+
+	// Now we have
+	// s: aaaaaaaavvvvbbbbcccccccc
+	//            ^   ^       ^   ^
+	//            i  i+m      n  n+m
+	// That's the result we want.
+	return s
+}
+
+// Delete removes the elements s[i:j] from s, returning the modified slice.
+// Delete panics if s[i:j] is not a valid slice of s.
+// Delete is O(len(s)-j), so if many items must be deleted, it is better to
+// make a single call deleting them all together than to delete one at a time.
+// Delete might not modify the elements s[len(s)-(j-i):len(s)]. If those
+// elements contain pointers you might consider zeroing those elements so that
+// objects they reference can be garbage collected.
+func Delete[S ~[]E, E any](s S, i, j int) S {
+	_ = s[i:j] // bounds check
+
+	return append(s[:i], s[j:]...)
+}
+
+// DeleteFunc removes any elements from s for which del returns true,
+// returning the modified slice.
+// When DeleteFunc removes m elements, it might not modify the elements
+// s[len(s)-m:len(s)]. If those elements contain pointers you might consider
+// zeroing those elements so that objects they reference can be garbage
+// collected.
+func DeleteFunc[S ~[]E, E any](s S, del func(E) bool) S {
+	// Don't start copying elements until we find one to delete.
+	for i, v := range s {
+		if del(v) {
+			j := i
+			for i++; i < len(s); i++ {
+				v = s[i]
+				if !del(v) {
+					s[j] = v
+					j++
+				}
+			}
+			return s[:j]
+		}
+	}
+	return s
+}
+
+// Replace replaces the elements s[i:j] by the given v, and returns the
+// modified slice. Replace panics if s[i:j] is not a valid slice of s.
+func Replace[S ~[]E, E any](s S, i, j int, v ...E) S {
+	_ = s[i:j] // verify that i:j is a valid subslice
+
+	if i == j {
+		return Insert(s, i, v...)
+	}
+	if j == len(s) {
+		return append(s[:i], v...)
+	}
+
+	tot := len(s[:i]) + len(v) + len(s[j:])
+	if tot > cap(s) {
+		// Too big to fit, allocate and copy over.
+		s2 := append(s[:i], make(S, tot-i)...) // See Insert
+		copy(s2[i:], v)
+		copy(s2[i+len(v):], s[j:])
+		return s2
+	}
+
+	r := s[:tot]
+
+	if i+len(v) <= j {
+		// Easy, as v fits in the deleted portion.
+		copy(r[i:], v)
+		if i+len(v) != j {
+			copy(r[i+len(v):], s[j:])
+		}
+		return r
+	}
+
+	// We are expanding (v is bigger than j-i).
+	// The situation is something like this:
+	// (example has i=4,j=8,len(s)=16,len(v)=6)
+	// s: aaaaxxxxbbbbbbbbyy
+	//        ^   ^       ^ ^
+	//        i   j  len(s) tot
+	// a: prefix of s
+	// x: deleted range
+	// b: more of s
+	// y: area to expand into
+
+	if !overlaps(r[i+len(v):], v) {
+		// Easy, as v is not clobbered by the first copy.
+		copy(r[i+len(v):], s[j:])
+		copy(r[i:], v)
+		return r
+	}
+
+	// This is a situation where we don't have a single place to which
+	// we can copy v. Parts of it need to go to two different places.
+	// We want to copy the prefix of v into y and the suffix into x, then
+	// rotate |y| spots to the right.
+	//
+	//        v[2:]      v[:2]
+	//         |           |
+	// s: aaaavvvvbbbbbbbbvv
+	//        ^   ^       ^ ^
+	//        i   j  len(s) tot
+	//
+	// If either of those two destinations don't alias v, then we're good.
+	y := len(v) - (j - i) // length of y portion
+
+	if !overlaps(r[i:j], v) {
+		copy(r[i:j], v[y:])
+		copy(r[len(s):], v[:y])
+		rotateRight(r[i:], y)
+		return r
+	}
+	if !overlaps(r[len(s):], v) {
+		copy(r[len(s):], v[:y])
+		copy(r[i:j], v[y:])
+		rotateRight(r[i:], y)
+		return r
+	}
+
+	// Now we know that v overlaps both x and y.
+	// That means that the entirety of b is *inside* v.
+	// So we don't need to preserve b at all; instead we
+	// can copy v first, then copy the b part of v out of
+	// v to the right destination.
+	k := startIdx(v, s[j:])
+	copy(r[i:], v)
+	copy(r[i+len(v):], r[i+k:])
+	return r
+}
+
+// Clone returns a copy of the slice.
+// The elements are copied using assignment, so this is a shallow clone.
+func Clone[S ~[]E, E any](s S) S {
+	// Preserve nil in case it matters.
+	if s == nil {
+		return nil
+	}
+	return append(S([]E{}), s...)
+}
+
+// Compact replaces consecutive runs of equal elements with a single copy.
+// This is like the uniq command found on Unix.
+// Compact modifies the contents of the slice s and returns the modified slice,
+// which may have a smaller length.
+// When Compact discards m elements in total, it might not modify the elements
+// s[len(s)-m:len(s)]. If those elements contain pointers you might consider
+// zeroing those elements so that objects they reference can be garbage collected.
+func Compact[S ~[]E, E comparable](s S) S {
+	if len(s) < 2 {
+		return s
+	}
+	i := 1
+	for k := 1; k < len(s); k++ {
+		if s[k] != s[k-1] {
+			if i != k {
+				s[i] = s[k]
+			}
+			i++
+		}
+	}
+	return s[:i]
+}
+
+// CompactFunc is like [Compact] but uses an equality function to compare elements.
+// For runs of elements that compare equal, CompactFunc keeps the first one.
+func CompactFunc[S ~[]E, E any](s S, eq func(E, E) bool) S {
+	if len(s) < 2 {
+		return s
+	}
+	i := 1
+	for k := 1; k < len(s); k++ {
+		if !eq(s[k], s[k-1]) {
+			if i != k {
+				s[i] = s[k]
+			}
+			i++
+		}
+	}
+	return s[:i]
+}
+
+// Grow increases the slice's capacity, if necessary, to guarantee space for
+// another n elements. After Grow(n), at least n elements can be appended
+// to the slice without another allocation. If n is negative or too large to
+// allocate the memory, Grow panics.
+func Grow[S ~[]E, E any](s S, n int) S {
+	if n < 0 {
+		panic("cannot be negative")
+	}
+	if n -= cap(s) - len(s); n > 0 {
+		s = append(s[:cap(s)], make([]E, n)...)[:len(s)]
+	}
+	return s
+}
+
+// Clip removes unused capacity from the slice, returning s[:len(s):len(s)].
+func Clip[S ~[]E, E any](s S) S {
+	return s[:len(s):len(s)]
+}
+
+// Rotation algorithm explanation:
+//
+// rotate left by 2
+// start with
+//   0123456789
+// split up like this
+//   01 234567 89
+// swap first 2 and last 2
+//   89 234567 01
+// join first parts
+//   89234567 01
+// recursively rotate first left part by 2
+//   23456789 01
+// join at the end
+//   2345678901
+//
+// rotate left by 8
+// start with
+//   0123456789
+// split up like this
+//   01 234567 89
+// swap first 2 and last 2
+//   89 234567 01
+// join last parts
+//   89 23456701
+// recursively rotate second part left by 6
+//   89 01234567
+// join at the end
+//   8901234567
+
+// TODO: There are other rotate algorithms.
+// This algorithm has the desirable property that it moves each element exactly twice.
+// The triple-reverse algorithm is simpler and more cache friendly, but takes more writes.
+// The follow-cycles algorithm can be 1-write but it is not very cache friendly.
+
+// rotateLeft rotates b left by n spaces.
+// s_final[i] = s_orig[i+r], wrapping around.
+func rotateLeft[E any](s []E, r int) {
+	for r != 0 && r != len(s) {
+		if r*2 <= len(s) {
+			swap(s[:r], s[len(s)-r:])
+			s = s[:len(s)-r]
+		} else {
+			swap(s[:len(s)-r], s[r:])
+			s, r = s[len(s)-r:], r*2-len(s)
+		}
+	}
+}
+func rotateRight[E any](s []E, r int) {
+	rotateLeft(s, len(s)-r)
+}
+
+// swap swaps the contents of x and y. x and y must be equal length and disjoint.
+func swap[E any](x, y []E) {
+	for i := 0; i < len(x); i++ {
+		x[i], y[i] = y[i], x[i]
+	}
+}
+
+// overlaps reports whether the memory ranges a[0:len(a)] and b[0:len(b)] overlap.
+func overlaps[E any](a, b []E) bool {
+	if len(a) == 0 || len(b) == 0 {
+		return false
+	}
+	elemSize := unsafe.Sizeof(a[0])
+	if elemSize == 0 {
+		return false
+	}
+	// TODO: use a runtime/unsafe facility once one becomes available. See issue 12445.
+	// Also see crypto/internal/alias/alias.go:AnyOverlap
+	return uintptr(unsafe.Pointer(&a[0])) <= uintptr(unsafe.Pointer(&b[len(b)-1]))+(elemSize-1) &&
+		uintptr(unsafe.Pointer(&b[0])) <= uintptr(unsafe.Pointer(&a[len(a)-1]))+(elemSize-1)
+}
+
+// startIdx returns the index in haystack where the needle starts.
+// prerequisite: the needle must be aliased entirely inside the haystack.
+func startIdx[E any](haystack, needle []E) int {
+	p := &needle[0]
+	for i := range haystack {
+		if p == &haystack[i] {
+			return i
+		}
+	}
+	// TODO: what if the overlap is by a non-integral number of Es?
+	panic("needle not found")
+}
+
+// Reverse reverses the elements of the slice in place.
+func Reverse[S ~[]E, E any](s S) {
+	for i, j := 0, len(s)-1; i < j; i, j = i+1, j-1 {
+		s[i], s[j] = s[j], s[i]
+	}
+}
diff --color -urN a/vendor/slices/slices_test.go b/vendor/slices/slices_test.go
--- a/vendor/slices/slices_test.go	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/slices/slices_test.go	2024-01-07 22:37:23.162035574 +0800
@@ -0,0 +1,1075 @@
+// Copyright 2021 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package slices
+
+import (
+	"cmp"
+	"internal/race"
+	"internal/testenv"
+	"math"
+	"strings"
+	"testing"
+)
+
+var equalIntTests = []struct {
+	s1, s2 []int
+	want   bool
+}{
+	{
+		[]int{1},
+		nil,
+		false,
+	},
+	{
+		[]int{},
+		nil,
+		true,
+	},
+	{
+		[]int{1, 2, 3},
+		[]int{1, 2, 3},
+		true,
+	},
+	{
+		[]int{1, 2, 3},
+		[]int{1, 2, 3, 4},
+		false,
+	},
+}
+
+var equalFloatTests = []struct {
+	s1, s2       []float64
+	wantEqual    bool
+	wantEqualNaN bool
+}{
+	{
+		[]float64{1, 2},
+		[]float64{1, 2},
+		true,
+		true,
+	},
+	{
+		[]float64{1, 2, math.NaN()},
+		[]float64{1, 2, math.NaN()},
+		false,
+		true,
+	},
+}
+
+func TestEqual(t *testing.T) {
+	for _, test := range equalIntTests {
+		if got := Equal(test.s1, test.s2); got != test.want {
+			t.Errorf("Equal(%v, %v) = %t, want %t", test.s1, test.s2, got, test.want)
+		}
+	}
+	for _, test := range equalFloatTests {
+		if got := Equal(test.s1, test.s2); got != test.wantEqual {
+			t.Errorf("Equal(%v, %v) = %t, want %t", test.s1, test.s2, got, test.wantEqual)
+		}
+	}
+}
+
+// equal is simply ==.
+func equal[T comparable](v1, v2 T) bool {
+	return v1 == v2
+}
+
+// equalNaN is like == except that all NaNs are equal.
+func equalNaN[T comparable](v1, v2 T) bool {
+	isNaN := func(f T) bool { return f != f }
+	return v1 == v2 || (isNaN(v1) && isNaN(v2))
+}
+
+// offByOne returns true if integers v1 and v2 differ by 1.
+func offByOne(v1, v2 int) bool {
+	return v1 == v2+1 || v1 == v2-1
+}
+
+func TestEqualFunc(t *testing.T) {
+	for _, test := range equalIntTests {
+		if got := EqualFunc(test.s1, test.s2, equal[int]); got != test.want {
+			t.Errorf("EqualFunc(%v, %v, equal[int]) = %t, want %t", test.s1, test.s2, got, test.want)
+		}
+	}
+	for _, test := range equalFloatTests {
+		if got := EqualFunc(test.s1, test.s2, equal[float64]); got != test.wantEqual {
+			t.Errorf("Equal(%v, %v, equal[float64]) = %t, want %t", test.s1, test.s2, got, test.wantEqual)
+		}
+		if got := EqualFunc(test.s1, test.s2, equalNaN[float64]); got != test.wantEqualNaN {
+			t.Errorf("Equal(%v, %v, equalNaN[float64]) = %t, want %t", test.s1, test.s2, got, test.wantEqualNaN)
+		}
+	}
+
+	s1 := []int{1, 2, 3}
+	s2 := []int{2, 3, 4}
+	if EqualFunc(s1, s1, offByOne) {
+		t.Errorf("EqualFunc(%v, %v, offByOne) = true, want false", s1, s1)
+	}
+	if !EqualFunc(s1, s2, offByOne) {
+		t.Errorf("EqualFunc(%v, %v, offByOne) = false, want true", s1, s2)
+	}
+
+	s3 := []string{"a", "b", "c"}
+	s4 := []string{"A", "B", "C"}
+	if !EqualFunc(s3, s4, strings.EqualFold) {
+		t.Errorf("EqualFunc(%v, %v, strings.EqualFold) = false, want true", s3, s4)
+	}
+
+	cmpIntString := func(v1 int, v2 string) bool {
+		return string(rune(v1)-1+'a') == v2
+	}
+	if !EqualFunc(s1, s3, cmpIntString) {
+		t.Errorf("EqualFunc(%v, %v, cmpIntString) = false, want true", s1, s3)
+	}
+}
+
+func BenchmarkEqualFunc_Large(b *testing.B) {
+	type Large [4 * 1024]byte
+
+	xs := make([]Large, 1024)
+	ys := make([]Large, 1024)
+	for i := 0; i < b.N; i++ {
+		_ = EqualFunc(xs, ys, func(x, y Large) bool { return x == y })
+	}
+}
+
+var compareIntTests = []struct {
+	s1, s2 []int
+	want   int
+}{
+	{
+		[]int{1},
+		[]int{1},
+		0,
+	},
+	{
+		[]int{1},
+		[]int{},
+		1,
+	},
+	{
+		[]int{},
+		[]int{1},
+		-1,
+	},
+	{
+		[]int{},
+		[]int{},
+		0,
+	},
+	{
+		[]int{1, 2, 3},
+		[]int{1, 2, 3},
+		0,
+	},
+	{
+		[]int{1, 2, 3},
+		[]int{1, 2, 3, 4},
+		-1,
+	},
+	{
+		[]int{1, 2, 3, 4},
+		[]int{1, 2, 3},
+		+1,
+	},
+	{
+		[]int{1, 2, 3},
+		[]int{1, 4, 3},
+		-1,
+	},
+	{
+		[]int{1, 4, 3},
+		[]int{1, 2, 3},
+		+1,
+	},
+	{
+		[]int{1, 4, 3},
+		[]int{1, 2, 3, 8, 9},
+		+1,
+	},
+}
+
+var compareFloatTests = []struct {
+	s1, s2 []float64
+	want   int
+}{
+	{
+		[]float64{},
+		[]float64{},
+		0,
+	},
+	{
+		[]float64{1},
+		[]float64{1},
+		0,
+	},
+	{
+		[]float64{math.NaN()},
+		[]float64{math.NaN()},
+		0,
+	},
+	{
+		[]float64{1, 2, math.NaN()},
+		[]float64{1, 2, math.NaN()},
+		0,
+	},
+	{
+		[]float64{1, math.NaN(), 3},
+		[]float64{1, math.NaN(), 4},
+		-1,
+	},
+	{
+		[]float64{1, math.NaN(), 3},
+		[]float64{1, 2, 4},
+		-1,
+	},
+	{
+		[]float64{1, math.NaN(), 3},
+		[]float64{1, 2, math.NaN()},
+		-1,
+	},
+	{
+		[]float64{1, 2, 3},
+		[]float64{1, 2, math.NaN()},
+		+1,
+	},
+	{
+		[]float64{1, 2, 3},
+		[]float64{1, math.NaN(), 3},
+		+1,
+	},
+	{
+		[]float64{1, math.NaN(), 3, 4},
+		[]float64{1, 2, math.NaN()},
+		-1,
+	},
+}
+
+func TestCompare(t *testing.T) {
+	intWant := func(want bool) string {
+		if want {
+			return "0"
+		}
+		return "!= 0"
+	}
+	for _, test := range equalIntTests {
+		if got := Compare(test.s1, test.s2); (got == 0) != test.want {
+			t.Errorf("Compare(%v, %v) = %d, want %s", test.s1, test.s2, got, intWant(test.want))
+		}
+	}
+	for _, test := range equalFloatTests {
+		if got := Compare(test.s1, test.s2); (got == 0) != test.wantEqualNaN {
+			t.Errorf("Compare(%v, %v) = %d, want %s", test.s1, test.s2, got, intWant(test.wantEqualNaN))
+		}
+	}
+
+	for _, test := range compareIntTests {
+		if got := Compare(test.s1, test.s2); got != test.want {
+			t.Errorf("Compare(%v, %v) = %d, want %d", test.s1, test.s2, got, test.want)
+		}
+	}
+	for _, test := range compareFloatTests {
+		if got := Compare(test.s1, test.s2); got != test.want {
+			t.Errorf("Compare(%v, %v) = %d, want %d", test.s1, test.s2, got, test.want)
+		}
+	}
+}
+
+func equalToCmp[T comparable](eq func(T, T) bool) func(T, T) int {
+	return func(v1, v2 T) int {
+		if eq(v1, v2) {
+			return 0
+		}
+		return 1
+	}
+}
+
+func TestCompareFunc(t *testing.T) {
+	intWant := func(want bool) string {
+		if want {
+			return "0"
+		}
+		return "!= 0"
+	}
+	for _, test := range equalIntTests {
+		if got := CompareFunc(test.s1, test.s2, equalToCmp(equal[int])); (got == 0) != test.want {
+			t.Errorf("CompareFunc(%v, %v, equalToCmp(equal[int])) = %d, want %s", test.s1, test.s2, got, intWant(test.want))
+		}
+	}
+	for _, test := range equalFloatTests {
+		if got := CompareFunc(test.s1, test.s2, equalToCmp(equal[float64])); (got == 0) != test.wantEqual {
+			t.Errorf("CompareFunc(%v, %v, equalToCmp(equal[float64])) = %d, want %s", test.s1, test.s2, got, intWant(test.wantEqual))
+		}
+	}
+
+	for _, test := range compareIntTests {
+		if got := CompareFunc(test.s1, test.s2, cmp.Compare[int]); got != test.want {
+			t.Errorf("CompareFunc(%v, %v, cmp[int]) = %d, want %d", test.s1, test.s2, got, test.want)
+		}
+	}
+	for _, test := range compareFloatTests {
+		if got := CompareFunc(test.s1, test.s2, cmp.Compare[float64]); got != test.want {
+			t.Errorf("CompareFunc(%v, %v, cmp[float64]) = %d, want %d", test.s1, test.s2, got, test.want)
+		}
+	}
+
+	s1 := []int{1, 2, 3}
+	s2 := []int{2, 3, 4}
+	if got := CompareFunc(s1, s2, equalToCmp(offByOne)); got != 0 {
+		t.Errorf("CompareFunc(%v, %v, offByOne) = %d, want 0", s1, s2, got)
+	}
+
+	s3 := []string{"a", "b", "c"}
+	s4 := []string{"A", "B", "C"}
+	if got := CompareFunc(s3, s4, strings.Compare); got != 1 {
+		t.Errorf("CompareFunc(%v, %v, strings.Compare) = %d, want 1", s3, s4, got)
+	}
+
+	compareLower := func(v1, v2 string) int {
+		return strings.Compare(strings.ToLower(v1), strings.ToLower(v2))
+	}
+	if got := CompareFunc(s3, s4, compareLower); got != 0 {
+		t.Errorf("CompareFunc(%v, %v, compareLower) = %d, want 0", s3, s4, got)
+	}
+
+	cmpIntString := func(v1 int, v2 string) int {
+		return strings.Compare(string(rune(v1)-1+'a'), v2)
+	}
+	if got := CompareFunc(s1, s3, cmpIntString); got != 0 {
+		t.Errorf("CompareFunc(%v, %v, cmpIntString) = %d, want 0", s1, s3, got)
+	}
+}
+
+var indexTests = []struct {
+	s    []int
+	v    int
+	want int
+}{
+	{
+		nil,
+		0,
+		-1,
+	},
+	{
+		[]int{},
+		0,
+		-1,
+	},
+	{
+		[]int{1, 2, 3},
+		2,
+		1,
+	},
+	{
+		[]int{1, 2, 2, 3},
+		2,
+		1,
+	},
+	{
+		[]int{1, 2, 3, 2},
+		2,
+		1,
+	},
+}
+
+func TestIndex(t *testing.T) {
+	for _, test := range indexTests {
+		if got := Index(test.s, test.v); got != test.want {
+			t.Errorf("Index(%v, %v) = %d, want %d", test.s, test.v, got, test.want)
+		}
+	}
+}
+
+func equalToIndex[T any](f func(T, T) bool, v1 T) func(T) bool {
+	return func(v2 T) bool {
+		return f(v1, v2)
+	}
+}
+
+func BenchmarkIndex_Large(b *testing.B) {
+	type Large [4 * 1024]byte
+
+	ss := make([]Large, 1024)
+	for i := 0; i < b.N; i++ {
+		_ = Index(ss, Large{1})
+	}
+}
+
+func TestIndexFunc(t *testing.T) {
+	for _, test := range indexTests {
+		if got := IndexFunc(test.s, equalToIndex(equal[int], test.v)); got != test.want {
+			t.Errorf("IndexFunc(%v, equalToIndex(equal[int], %v)) = %d, want %d", test.s, test.v, got, test.want)
+		}
+	}
+
+	s1 := []string{"hi", "HI"}
+	if got := IndexFunc(s1, equalToIndex(equal[string], "HI")); got != 1 {
+		t.Errorf("IndexFunc(%v, equalToIndex(equal[string], %q)) = %d, want %d", s1, "HI", got, 1)
+	}
+	if got := IndexFunc(s1, equalToIndex(strings.EqualFold, "HI")); got != 0 {
+		t.Errorf("IndexFunc(%v, equalToIndex(strings.EqualFold, %q)) = %d, want %d", s1, "HI", got, 0)
+	}
+}
+
+func BenchmarkIndexFunc_Large(b *testing.B) {
+	type Large [4 * 1024]byte
+
+	ss := make([]Large, 1024)
+	for i := 0; i < b.N; i++ {
+		_ = IndexFunc(ss, func(e Large) bool {
+			return e == Large{1}
+		})
+	}
+}
+
+func TestContains(t *testing.T) {
+	for _, test := range indexTests {
+		if got := Contains(test.s, test.v); got != (test.want != -1) {
+			t.Errorf("Contains(%v, %v) = %t, want %t", test.s, test.v, got, test.want != -1)
+		}
+	}
+}
+
+func TestContainsFunc(t *testing.T) {
+	for _, test := range indexTests {
+		if got := ContainsFunc(test.s, equalToIndex(equal[int], test.v)); got != (test.want != -1) {
+			t.Errorf("ContainsFunc(%v, equalToIndex(equal[int], %v)) = %t, want %t", test.s, test.v, got, test.want != -1)
+		}
+	}
+
+	s1 := []string{"hi", "HI"}
+	if got := ContainsFunc(s1, equalToIndex(equal[string], "HI")); got != true {
+		t.Errorf("ContainsFunc(%v, equalToContains(equal[string], %q)) = %t, want %t", s1, "HI", got, true)
+	}
+	if got := ContainsFunc(s1, equalToIndex(equal[string], "hI")); got != false {
+		t.Errorf("ContainsFunc(%v, equalToContains(strings.EqualFold, %q)) = %t, want %t", s1, "hI", got, false)
+	}
+	if got := ContainsFunc(s1, equalToIndex(strings.EqualFold, "hI")); got != true {
+		t.Errorf("ContainsFunc(%v, equalToContains(strings.EqualFold, %q)) = %t, want %t", s1, "hI", got, true)
+	}
+}
+
+var insertTests = []struct {
+	s    []int
+	i    int
+	add  []int
+	want []int
+}{
+	{
+		[]int{1, 2, 3},
+		0,
+		[]int{4},
+		[]int{4, 1, 2, 3},
+	},
+	{
+		[]int{1, 2, 3},
+		1,
+		[]int{4},
+		[]int{1, 4, 2, 3},
+	},
+	{
+		[]int{1, 2, 3},
+		3,
+		[]int{4},
+		[]int{1, 2, 3, 4},
+	},
+	{
+		[]int{1, 2, 3},
+		2,
+		[]int{4, 5},
+		[]int{1, 2, 4, 5, 3},
+	},
+}
+
+func TestInsert(t *testing.T) {
+	s := []int{1, 2, 3}
+	if got := Insert(s, 0); !Equal(got, s) {
+		t.Errorf("Insert(%v, 0) = %v, want %v", s, got, s)
+	}
+	for _, test := range insertTests {
+		copy := Clone(test.s)
+		if got := Insert(copy, test.i, test.add...); !Equal(got, test.want) {
+			t.Errorf("Insert(%v, %d, %v...) = %v, want %v", test.s, test.i, test.add, got, test.want)
+		}
+	}
+
+	if !testenv.OptimizationOff() && !race.Enabled {
+		// Allocations should be amortized.
+		const count = 50
+		n := testing.AllocsPerRun(10, func() {
+			s := []int{1, 2, 3}
+			for i := 0; i < count; i++ {
+				s = Insert(s, 0, 1)
+			}
+		})
+		if n > count/2 {
+			t.Errorf("too many allocations inserting %d elements: got %v, want less than %d", count, n, count/2)
+		}
+	}
+}
+
+func TestInsertOverlap(t *testing.T) {
+	const N = 10
+	a := make([]int, N)
+	want := make([]int, 2*N)
+	for n := 0; n <= N; n++ { // length
+		for i := 0; i <= n; i++ { // insertion point
+			for x := 0; x <= N; x++ { // start of inserted data
+				for y := x; y <= N; y++ { // end of inserted data
+					for k := 0; k < N; k++ {
+						a[k] = k
+					}
+					want = want[:0]
+					want = append(want, a[:i]...)
+					want = append(want, a[x:y]...)
+					want = append(want, a[i:n]...)
+					got := Insert(a[:n], i, a[x:y]...)
+					if !Equal(got, want) {
+						t.Errorf("Insert with overlap failed n=%d i=%d x=%d y=%d, got %v want %v", n, i, x, y, got, want)
+					}
+				}
+			}
+		}
+	}
+}
+
+var deleteTests = []struct {
+	s    []int
+	i, j int
+	want []int
+}{
+	{
+		[]int{1, 2, 3},
+		0,
+		0,
+		[]int{1, 2, 3},
+	},
+	{
+		[]int{1, 2, 3},
+		0,
+		1,
+		[]int{2, 3},
+	},
+	{
+		[]int{1, 2, 3},
+		3,
+		3,
+		[]int{1, 2, 3},
+	},
+	{
+		[]int{1, 2, 3},
+		0,
+		2,
+		[]int{3},
+	},
+	{
+		[]int{1, 2, 3},
+		0,
+		3,
+		[]int{},
+	},
+}
+
+func TestDelete(t *testing.T) {
+	for _, test := range deleteTests {
+		copy := Clone(test.s)
+		if got := Delete(copy, test.i, test.j); !Equal(got, test.want) {
+			t.Errorf("Delete(%v, %d, %d) = %v, want %v", test.s, test.i, test.j, got, test.want)
+		}
+	}
+}
+
+var deleteFuncTests = []struct {
+	s    []int
+	fn   func(int) bool
+	want []int
+}{
+	{
+		nil,
+		func(int) bool { return true },
+		nil,
+	},
+	{
+		[]int{1, 2, 3},
+		func(int) bool { return true },
+		nil,
+	},
+	{
+		[]int{1, 2, 3},
+		func(int) bool { return false },
+		[]int{1, 2, 3},
+	},
+	{
+		[]int{1, 2, 3},
+		func(i int) bool { return i > 2 },
+		[]int{1, 2},
+	},
+	{
+		[]int{1, 2, 3},
+		func(i int) bool { return i < 2 },
+		[]int{2, 3},
+	},
+	{
+		[]int{10, 2, 30},
+		func(i int) bool { return i >= 10 },
+		[]int{2},
+	},
+}
+
+func TestDeleteFunc(t *testing.T) {
+	for i, test := range deleteFuncTests {
+		copy := Clone(test.s)
+		if got := DeleteFunc(copy, test.fn); !Equal(got, test.want) {
+			t.Errorf("DeleteFunc case %d: got %v, want %v", i, got, test.want)
+		}
+	}
+}
+
+func panics(f func()) (b bool) {
+	defer func() {
+		if x := recover(); x != nil {
+			b = true
+		}
+	}()
+	f()
+	return false
+}
+
+func TestDeletePanics(t *testing.T) {
+	for _, test := range []struct {
+		name string
+		s    []int
+		i, j int
+	}{
+		{"with negative first index", []int{42}, -2, 1},
+		{"with negative second index", []int{42}, 1, -1},
+		{"with out-of-bounds first index", []int{42}, 2, 3},
+		{"with out-of-bounds second index", []int{42}, 0, 2},
+		{"with invalid i>j", []int{42}, 1, 0},
+	} {
+		if !panics(func() { Delete(test.s, test.i, test.j) }) {
+			t.Errorf("Delete %s: got no panic, want panic", test.name)
+		}
+	}
+}
+
+func TestClone(t *testing.T) {
+	s1 := []int{1, 2, 3}
+	s2 := Clone(s1)
+	if !Equal(s1, s2) {
+		t.Errorf("Clone(%v) = %v, want %v", s1, s2, s1)
+	}
+	s1[0] = 4
+	want := []int{1, 2, 3}
+	if !Equal(s2, want) {
+		t.Errorf("Clone(%v) changed unexpectedly to %v", want, s2)
+	}
+	if got := Clone([]int(nil)); got != nil {
+		t.Errorf("Clone(nil) = %#v, want nil", got)
+	}
+	if got := Clone(s1[:0]); got == nil || len(got) != 0 {
+		t.Errorf("Clone(%v) = %#v, want %#v", s1[:0], got, s1[:0])
+	}
+}
+
+var compactTests = []struct {
+	name string
+	s    []int
+	want []int
+}{
+	{
+		"nil",
+		nil,
+		nil,
+	},
+	{
+		"one",
+		[]int{1},
+		[]int{1},
+	},
+	{
+		"sorted",
+		[]int{1, 2, 3},
+		[]int{1, 2, 3},
+	},
+	{
+		"1 item",
+		[]int{1, 1, 2},
+		[]int{1, 2},
+	},
+	{
+		"unsorted",
+		[]int{1, 2, 1},
+		[]int{1, 2, 1},
+	},
+	{
+		"many",
+		[]int{1, 2, 2, 3, 3, 4},
+		[]int{1, 2, 3, 4},
+	},
+}
+
+func TestCompact(t *testing.T) {
+	for _, test := range compactTests {
+		copy := Clone(test.s)
+		if got := Compact(copy); !Equal(got, test.want) {
+			t.Errorf("Compact(%v) = %v, want %v", test.s, got, test.want)
+		}
+	}
+}
+
+func BenchmarkCompact(b *testing.B) {
+	for _, c := range compactTests {
+		b.Run(c.name, func(b *testing.B) {
+			ss := make([]int, 0, 64)
+			for k := 0; k < b.N; k++ {
+				ss = ss[:0]
+				ss = append(ss, c.s...)
+				_ = Compact(ss)
+			}
+		})
+	}
+}
+
+func BenchmarkCompact_Large(b *testing.B) {
+	type Large [4 * 1024]byte
+
+	ss := make([]Large, 1024)
+	for i := 0; i < b.N; i++ {
+		_ = Compact(ss)
+	}
+}
+
+func TestCompactFunc(t *testing.T) {
+	for _, test := range compactTests {
+		copy := Clone(test.s)
+		if got := CompactFunc(copy, equal[int]); !Equal(got, test.want) {
+			t.Errorf("CompactFunc(%v, equal[int]) = %v, want %v", test.s, got, test.want)
+		}
+	}
+
+	s1 := []string{"a", "a", "A", "B", "b"}
+	copy := Clone(s1)
+	want := []string{"a", "B"}
+	if got := CompactFunc(copy, strings.EqualFold); !Equal(got, want) {
+		t.Errorf("CompactFunc(%v, strings.EqualFold) = %v, want %v", s1, got, want)
+	}
+}
+
+func BenchmarkCompactFunc_Large(b *testing.B) {
+	type Large [4 * 1024]byte
+
+	ss := make([]Large, 1024)
+	for i := 0; i < b.N; i++ {
+		_ = CompactFunc(ss, func(a, b Large) bool { return a == b })
+	}
+}
+
+func TestGrow(t *testing.T) {
+	s1 := []int{1, 2, 3}
+
+	copy := Clone(s1)
+	s2 := Grow(copy, 1000)
+	if !Equal(s1, s2) {
+		t.Errorf("Grow(%v) = %v, want %v", s1, s2, s1)
+	}
+	if cap(s2) < 1000+len(s1) {
+		t.Errorf("after Grow(%v) cap = %d, want >= %d", s1, cap(s2), 1000+len(s1))
+	}
+
+	// Test mutation of elements between length and capacity.
+	copy = Clone(s1)
+	s3 := Grow(copy[:1], 2)[:3]
+	if !Equal(s1, s3) {
+		t.Errorf("Grow should not mutate elements between length and capacity")
+	}
+	s3 = Grow(copy[:1], 1000)[:3]
+	if !Equal(s1, s3) {
+		t.Errorf("Grow should not mutate elements between length and capacity")
+	}
+
+	// Test number of allocations.
+	if n := testing.AllocsPerRun(100, func() { Grow(s2, cap(s2)-len(s2)) }); n != 0 {
+		t.Errorf("Grow should not allocate when given sufficient capacity; allocated %v times", n)
+	}
+	if n := testing.AllocsPerRun(100, func() { Grow(s2, cap(s2)-len(s2)+1) }); n != 1 {
+		errorf := t.Errorf
+		if race.Enabled || testenv.OptimizationOff() {
+			errorf = t.Logf // this allocates multiple times in race detector mode
+		}
+		errorf("Grow should allocate once when given insufficient capacity; allocated %v times", n)
+	}
+
+	// Test for negative growth sizes.
+	var gotPanic bool
+	func() {
+		defer func() { gotPanic = recover() != nil }()
+		Grow(s1, -1)
+	}()
+	if !gotPanic {
+		t.Errorf("Grow(-1) did not panic; expected a panic")
+	}
+}
+
+func TestClip(t *testing.T) {
+	s1 := []int{1, 2, 3, 4, 5, 6}[:3]
+	orig := Clone(s1)
+	if len(s1) != 3 {
+		t.Errorf("len(%v) = %d, want 3", s1, len(s1))
+	}
+	if cap(s1) < 6 {
+		t.Errorf("cap(%v[:3]) = %d, want >= 6", orig, cap(s1))
+	}
+	s2 := Clip(s1)
+	if !Equal(s1, s2) {
+		t.Errorf("Clip(%v) = %v, want %v", s1, s2, s1)
+	}
+	if cap(s2) != 3 {
+		t.Errorf("cap(Clip(%v)) = %d, want 3", orig, cap(s2))
+	}
+}
+
+func TestReverse(t *testing.T) {
+	even := []int{3, 1, 4, 1, 5, 9} // len = 6
+	Reverse(even)
+	if want := []int{9, 5, 1, 4, 1, 3}; !Equal(even, want) {
+		t.Errorf("Reverse(even) = %v, want %v", even, want)
+	}
+
+	odd := []int{3, 1, 4, 1, 5, 9, 2} // len = 7
+	Reverse(odd)
+	if want := []int{2, 9, 5, 1, 4, 1, 3}; !Equal(odd, want) {
+		t.Errorf("Reverse(odd) = %v, want %v", odd, want)
+	}
+
+	words := strings.Fields("one two three")
+	Reverse(words)
+	if want := strings.Fields("three two one"); !Equal(words, want) {
+		t.Errorf("Reverse(words) = %v, want %v", words, want)
+	}
+
+	singleton := []string{"one"}
+	Reverse(singleton)
+	if want := []string{"one"}; !Equal(singleton, want) {
+		t.Errorf("Reverse(singeleton) = %v, want %v", singleton, want)
+	}
+
+	Reverse[[]string](nil)
+}
+
+// naiveReplace is a baseline implementation to the Replace function.
+func naiveReplace[S ~[]E, E any](s S, i, j int, v ...E) S {
+	s = Delete(s, i, j)
+	s = Insert(s, i, v...)
+	return s
+}
+
+func TestReplace(t *testing.T) {
+	for _, test := range []struct {
+		s, v []int
+		i, j int
+	}{
+		{}, // all zero value
+		{
+			s: []int{1, 2, 3, 4},
+			v: []int{5},
+			i: 1,
+			j: 2,
+		},
+		{
+			s: []int{1, 2, 3, 4},
+			v: []int{5, 6, 7, 8},
+			i: 1,
+			j: 2,
+		},
+		{
+			s: func() []int {
+				s := make([]int, 3, 20)
+				s[0] = 0
+				s[1] = 1
+				s[2] = 2
+				return s
+			}(),
+			v: []int{3, 4, 5, 6, 7},
+			i: 0,
+			j: 1,
+		},
+	} {
+		ss, vv := Clone(test.s), Clone(test.v)
+		want := naiveReplace(ss, test.i, test.j, vv...)
+		got := Replace(test.s, test.i, test.j, test.v...)
+		if !Equal(got, want) {
+			t.Errorf("Replace(%v, %v, %v, %v) = %v, want %v", test.s, test.i, test.j, test.v, got, want)
+		}
+	}
+}
+
+func TestReplacePanics(t *testing.T) {
+	for _, test := range []struct {
+		name string
+		s, v []int
+		i, j int
+	}{
+		{"indexes out of order", []int{1, 2}, []int{3}, 2, 1},
+		{"large index", []int{1, 2}, []int{3}, 1, 10},
+		{"negative index", []int{1, 2}, []int{3}, -1, 2},
+	} {
+		ss, vv := Clone(test.s), Clone(test.v)
+		if !panics(func() { Replace(ss, test.i, test.j, vv...) }) {
+			t.Errorf("Replace %s: should have panicked", test.name)
+		}
+	}
+}
+
+func TestReplaceOverlap(t *testing.T) {
+	const N = 10
+	a := make([]int, N)
+	want := make([]int, 2*N)
+	for n := 0; n <= N; n++ { // length
+		for i := 0; i <= n; i++ { // insertion point 1
+			for j := i; j <= n; j++ { // insertion point 2
+				for x := 0; x <= N; x++ { // start of inserted data
+					for y := x; y <= N; y++ { // end of inserted data
+						for k := 0; k < N; k++ {
+							a[k] = k
+						}
+						want = want[:0]
+						want = append(want, a[:i]...)
+						want = append(want, a[x:y]...)
+						want = append(want, a[j:n]...)
+						got := Replace(a[:n], i, j, a[x:y]...)
+						if !Equal(got, want) {
+							t.Errorf("Insert with overlap failed n=%d i=%d j=%d x=%d y=%d, got %v want %v", n, i, j, x, y, got, want)
+						}
+					}
+				}
+			}
+		}
+	}
+}
+
+func BenchmarkReplace(b *testing.B) {
+	cases := []struct {
+		name string
+		s, v func() []int
+		i, j int
+	}{
+		{
+			name: "fast",
+			s: func() []int {
+				return make([]int, 100)
+			},
+			v: func() []int {
+				return make([]int, 20)
+			},
+			i: 10,
+			j: 40,
+		},
+		{
+			name: "slow",
+			s: func() []int {
+				return make([]int, 100)
+			},
+			v: func() []int {
+				return make([]int, 20)
+			},
+			i: 0,
+			j: 2,
+		},
+	}
+
+	for _, c := range cases {
+		b.Run("naive-"+c.name, func(b *testing.B) {
+			for k := 0; k < b.N; k++ {
+				s := c.s()
+				v := c.v()
+				_ = naiveReplace(s, c.i, c.j, v...)
+			}
+		})
+		b.Run("optimized-"+c.name, func(b *testing.B) {
+			for k := 0; k < b.N; k++ {
+				s := c.s()
+				v := c.v()
+				_ = Replace(s, c.i, c.j, v...)
+			}
+		})
+	}
+
+}
+
+func TestRotate(t *testing.T) {
+	const N = 10
+	s := make([]int, 0, N)
+	for n := 0; n < N; n++ {
+		for r := 0; r < n; r++ {
+			s = s[:0]
+			for i := 0; i < n; i++ {
+				s = append(s, i)
+			}
+			rotateLeft(s, r)
+			for i := 0; i < n; i++ {
+				if s[i] != (i+r)%n {
+					t.Errorf("expected n=%d r=%d i:%d want:%d got:%d", n, r, i, (i+r)%n, s[i])
+				}
+			}
+		}
+	}
+}
+
+func TestInsertGrowthRate(t *testing.T) {
+	b := make([]byte, 1)
+	maxCap := cap(b)
+	nGrow := 0
+	const N = 1e6
+	for i := 0; i < N; i++ {
+		b = Insert(b, len(b)-1, 0)
+		if cap(b) > maxCap {
+			maxCap = cap(b)
+			nGrow++
+		}
+	}
+	want := int(math.Log(N) / math.Log(1.25)) // 1.25 == growth rate for large slices
+	if nGrow > want {
+		t.Errorf("too many grows. got:%d want:%d", nGrow, want)
+	}
+}
+
+func TestReplaceGrowthRate(t *testing.T) {
+	b := make([]byte, 2)
+	maxCap := cap(b)
+	nGrow := 0
+	const N = 1e6
+	for i := 0; i < N; i++ {
+		b = Replace(b, len(b)-2, len(b)-1, 0, 0)
+		if cap(b) > maxCap {
+			maxCap = cap(b)
+			nGrow++
+		}
+	}
+	want := int(math.Log(N) / math.Log(1.25)) // 1.25 == growth rate for large slices
+	if nGrow > want {
+		t.Errorf("too many grows. got:%d want:%d", nGrow, want)
+	}
+}
+
+func apply[T any](v T, f func(T)) {
+	f(v)
+}
+
+// Test type inference with a named slice type.
+func TestInference(t *testing.T) {
+	s1 := []int{1, 2, 3}
+	apply(s1, Reverse)
+	if want := []int{3, 2, 1}; !Equal(s1, want) {
+		t.Errorf("Reverse(%v) = %v, want %v", []int{1, 2, 3}, s1, want)
+	}
+
+	type S []int
+	s2 := S{4, 5, 6}
+	apply(s2, Reverse)
+	if want := (S{6, 5, 4}); !Equal(s2, want) {
+		t.Errorf("Reverse(%v) = %v, want %v", S{4, 5, 6}, s2, want)
+	}
+}
diff --color -urN a/vendor/slices/sort.go b/vendor/slices/sort.go
--- a/vendor/slices/sort.go	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/slices/sort.go	2024-01-07 22:37:23.162035574 +0800
@@ -0,0 +1,196 @@
+// Copyright 2023 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package slices
+
+import (
+	"cmp"
+	"math/bits"
+)
+
+// Sort sorts a slice of any ordered type in ascending order.
+// When sorting floating-point numbers, NaNs are ordered before other values.
+func Sort[S ~[]E, E cmp.Ordered](x S) {
+	n := len(x)
+	pdqsortOrdered(x, 0, n, bits.Len(uint(n)))
+}
+
+// SortFunc sorts the slice x in ascending order as determined by the cmp
+// function. This sort is not guaranteed to be stable.
+// cmp(a, b) should return a negative number when a < b, a positive number when
+// a > b and zero when a == b.
+//
+// SortFunc requires that cmp is a strict weak ordering.
+// See https://en.wikipedia.org/wiki/Weak_ordering#Strict_weak_orderings.
+func SortFunc[S ~[]E, E any](x S, cmp func(a, b E) int) {
+	n := len(x)
+	pdqsortCmpFunc(x, 0, n, bits.Len(uint(n)), cmp)
+}
+
+// SortStableFunc sorts the slice x while keeping the original order of equal
+// elements, using cmp to compare elements in the same way as [SortFunc].
+func SortStableFunc[S ~[]E, E any](x S, cmp func(a, b E) int) {
+	stableCmpFunc(x, len(x), cmp)
+}
+
+// IsSorted reports whether x is sorted in ascending order.
+func IsSorted[S ~[]E, E cmp.Ordered](x S) bool {
+	for i := len(x) - 1; i > 0; i-- {
+		if cmp.Less(x[i], x[i-1]) {
+			return false
+		}
+	}
+	return true
+}
+
+// IsSortedFunc reports whether x is sorted in ascending order, with cmp as the
+// comparison function as defined by [SortFunc].
+func IsSortedFunc[S ~[]E, E any](x S, cmp func(a, b E) int) bool {
+	for i := len(x) - 1; i > 0; i-- {
+		if cmp(x[i], x[i-1]) < 0 {
+			return false
+		}
+	}
+	return true
+}
+
+// Min returns the minimal value in x. It panics if x is empty.
+// For floating-point numbers, Min propagates NaNs (any NaN value in x
+// forces the output to be NaN).
+func Min[S ~[]E, E cmp.Ordered](x S) E {
+	if len(x) < 1 {
+		panic("slices.Min: empty list")
+	}
+	m := x[0]
+	for i := 1; i < len(x); i++ {
+		if x[i] < m {
+			m = x[i]
+		}
+	}
+	return m
+}
+
+// MinFunc returns the minimal value in x, using cmp to compare elements.
+// It panics if x is empty. If there is more than one minimal element
+// according to the cmp function, MinFunc returns the first one.
+func MinFunc[S ~[]E, E any](x S, cmp func(a, b E) int) E {
+	if len(x) < 1 {
+		panic("slices.MinFunc: empty list")
+	}
+	m := x[0]
+	for i := 1; i < len(x); i++ {
+		if cmp(x[i], m) < 0 {
+			m = x[i]
+		}
+	}
+	return m
+}
+
+// Max returns the maximal value in x. It panics if x is empty.
+// For floating-point E, Max propagates NaNs (any NaN value in x
+// forces the output to be NaN).
+func Max[S ~[]E, E cmp.Ordered](x S) E {
+	if len(x) < 1 {
+		panic("slices.Max: empty list")
+	}
+	m := x[0]
+	for i := 1; i < len(x); i++ {
+		if x[i] > m {
+			m = x[i]
+		}
+	}
+	return m
+}
+
+// MaxFunc returns the maximal value in x, using cmp to compare elements.
+// It panics if x is empty. If there is more than one maximal element
+// according to the cmp function, MaxFunc returns the first one.
+func MaxFunc[S ~[]E, E any](x S, cmp func(a, b E) int) E {
+	if len(x) < 1 {
+		panic("slices.MaxFunc: empty list")
+	}
+	m := x[0]
+	for i := 1; i < len(x); i++ {
+		if cmp(x[i], m) > 0 {
+			m = x[i]
+		}
+	}
+	return m
+}
+
+// BinarySearch searches for target in a sorted slice and returns the position
+// where target is found, or the position where target would appear in the
+// sort order; it also returns a bool saying whether the target is really found
+// in the slice. The slice must be sorted in increasing order.
+func BinarySearch[S ~[]E, E cmp.Ordered](x S, target E) (int, bool) {
+	// Inlining is faster than calling BinarySearchFunc with a lambda.
+	n := len(x)
+	// Define x[-1] < target and x[n] >= target.
+	// Invariant: x[i-1] < target, x[j] >= target.
+	i, j := 0, n
+	for i < j {
+		h := int(uint(i+j) >> 1) // avoid overflow when computing h
+		// i ≤ h < j
+		if cmp.Less(x[h], target) {
+			i = h + 1 // preserves x[i-1] < target
+		} else {
+			j = h // preserves x[j] >= target
+		}
+	}
+	// i == j, x[i-1] < target, and x[j] (= x[i]) >= target  =>  answer is i.
+	return i, i < n && (x[i] == target || (isNaN(x[i]) && isNaN(target)))
+}
+
+// BinarySearchFunc works like [BinarySearch], but uses a custom comparison
+// function. The slice must be sorted in increasing order, where "increasing"
+// is defined by cmp. cmp should return 0 if the slice element matches
+// the target, a negative number if the slice element precedes the target,
+// or a positive number if the slice element follows the target.
+// cmp must implement the same ordering as the slice, such that if
+// cmp(a, t) < 0 and cmp(b, t) >= 0, then a must precede b in the slice.
+func BinarySearchFunc[S ~[]E, E, T any](x S, target T, cmp func(E, T) int) (int, bool) {
+	n := len(x)
+	// Define cmp(x[-1], target) < 0 and cmp(x[n], target) >= 0 .
+	// Invariant: cmp(x[i - 1], target) < 0, cmp(x[j], target) >= 0.
+	i, j := 0, n
+	for i < j {
+		h := int(uint(i+j) >> 1) // avoid overflow when computing h
+		// i ≤ h < j
+		if cmp(x[h], target) < 0 {
+			i = h + 1 // preserves cmp(x[i - 1], target) < 0
+		} else {
+			j = h // preserves cmp(x[j], target) >= 0
+		}
+	}
+	// i == j, cmp(x[i-1], target) < 0, and cmp(x[j], target) (= cmp(x[i], target)) >= 0  =>  answer is i.
+	return i, i < n && cmp(x[i], target) == 0
+}
+
+type sortedHint int // hint for pdqsort when choosing the pivot
+
+const (
+	unknownHint sortedHint = iota
+	increasingHint
+	decreasingHint
+)
+
+// xorshift paper: https://www.jstatsoft.org/article/view/v008i14/xorshift.pdf
+type xorshift uint64
+
+func (r *xorshift) Next() uint64 {
+	*r ^= *r << 13
+	*r ^= *r >> 17
+	*r ^= *r << 5
+	return uint64(*r)
+}
+
+func nextPowerOfTwo(length int) uint {
+	return 1 << bits.Len(uint(length))
+}
+
+// isNaN reports whether x is a NaN without requiring the math package.
+// This will always return false if T is not floating-point.
+func isNaN[T cmp.Ordered](x T) bool {
+	return x != x
+}
diff --color -urN a/vendor/slices/sort_benchmark_test.go b/vendor/slices/sort_benchmark_test.go
--- a/vendor/slices/sort_benchmark_test.go	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/slices/sort_benchmark_test.go	2024-01-07 22:37:23.162035574 +0800
@@ -0,0 +1,284 @@
+// Copyright 2023 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package slices
+
+import (
+	"fmt"
+	"math/rand"
+	"sort"
+	"strconv"
+	"strings"
+	"testing"
+)
+
+// These benchmarks compare sorting a large slice of int with sort.Ints vs.
+// slices.Sort
+func makeRandomInts(n int) []int {
+	rand.Seed(42)
+	ints := make([]int, n)
+	for i := 0; i < n; i++ {
+		ints[i] = rand.Intn(n)
+	}
+	return ints
+}
+
+func makeSortedInts(n int) []int {
+	ints := make([]int, n)
+	for i := 0; i < n; i++ {
+		ints[i] = i
+	}
+	return ints
+}
+
+func makeReversedInts(n int) []int {
+	ints := make([]int, n)
+	for i := 0; i < n; i++ {
+		ints[i] = n - i
+	}
+	return ints
+}
+
+const N = 100_000
+
+func BenchmarkSortInts(b *testing.B) {
+	for i := 0; i < b.N; i++ {
+		b.StopTimer()
+		ints := makeRandomInts(N)
+		b.StartTimer()
+		sort.Ints(ints)
+	}
+}
+
+func makeSortedStrings(n int) []string {
+	x := make([]string, n)
+	for i := 0; i < n; i++ {
+		x[i] = strconv.Itoa(i)
+	}
+	Sort(x)
+	return x
+}
+
+func BenchmarkSlicesSortInts(b *testing.B) {
+	for i := 0; i < b.N; i++ {
+		b.StopTimer()
+		ints := makeRandomInts(N)
+		b.StartTimer()
+		Sort(ints)
+	}
+}
+
+func BenchmarkSlicesSortInts_Sorted(b *testing.B) {
+	for i := 0; i < b.N; i++ {
+		b.StopTimer()
+		ints := makeSortedInts(N)
+		b.StartTimer()
+		Sort(ints)
+	}
+}
+
+func BenchmarkSlicesSortInts_Reversed(b *testing.B) {
+	for i := 0; i < b.N; i++ {
+		b.StopTimer()
+		ints := makeReversedInts(N)
+		b.StartTimer()
+		Sort(ints)
+	}
+}
+
+func BenchmarkIntsAreSorted(b *testing.B) {
+	for i := 0; i < b.N; i++ {
+		b.StopTimer()
+		ints := makeSortedInts(N)
+		b.StartTimer()
+		sort.IntsAreSorted(ints)
+	}
+}
+
+func BenchmarkIsSorted(b *testing.B) {
+	for i := 0; i < b.N; i++ {
+		b.StopTimer()
+		ints := makeSortedInts(N)
+		b.StartTimer()
+		IsSorted(ints)
+	}
+}
+
+// Since we're benchmarking these sorts against each other, make sure that they
+// generate similar results.
+func TestIntSorts(t *testing.T) {
+	ints := makeRandomInts(200)
+	ints2 := Clone(ints)
+
+	sort.Ints(ints)
+	Sort(ints2)
+
+	for i := range ints {
+		if ints[i] != ints2[i] {
+			t.Fatalf("ints2 mismatch at %d; %d != %d", i, ints[i], ints2[i])
+		}
+	}
+}
+
+// The following is a benchmark for sorting strings.
+
+// makeRandomStrings generates n random strings with alphabetic runes of
+// varying lengths.
+func makeRandomStrings(n int) []string {
+	rand.Seed(42)
+	var letters = []rune("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")
+	ss := make([]string, n)
+	for i := 0; i < n; i++ {
+		var sb strings.Builder
+		slen := 2 + rand.Intn(50)
+		for j := 0; j < slen; j++ {
+			sb.WriteRune(letters[rand.Intn(len(letters))])
+		}
+		ss[i] = sb.String()
+	}
+	return ss
+}
+
+func TestStringSorts(t *testing.T) {
+	ss := makeRandomStrings(200)
+	ss2 := Clone(ss)
+
+	sort.Strings(ss)
+	Sort(ss2)
+
+	for i := range ss {
+		if ss[i] != ss2[i] {
+			t.Fatalf("ss2 mismatch at %d; %s != %s", i, ss[i], ss2[i])
+		}
+	}
+}
+
+func BenchmarkSortStrings(b *testing.B) {
+	for i := 0; i < b.N; i++ {
+		b.StopTimer()
+		ss := makeRandomStrings(N)
+		b.StartTimer()
+		sort.Strings(ss)
+	}
+}
+
+func BenchmarkSortStrings_Sorted(b *testing.B) {
+	ss := makeSortedStrings(N)
+	b.ResetTimer()
+
+	for i := 0; i < b.N; i++ {
+		sort.Strings(ss)
+	}
+}
+
+func BenchmarkSlicesSortStrings(b *testing.B) {
+	for i := 0; i < b.N; i++ {
+		b.StopTimer()
+		ss := makeRandomStrings(N)
+		b.StartTimer()
+		Sort(ss)
+	}
+}
+
+func BenchmarkSlicesSortStrings_Sorted(b *testing.B) {
+	ss := makeSortedStrings(N)
+	b.ResetTimer()
+
+	for i := 0; i < b.N; i++ {
+		Sort(ss)
+	}
+}
+
+// These benchmarks compare sorting a slice of structs with sort.Sort vs.
+// slices.SortFunc.
+type myStruct struct {
+	a, b, c, d string
+	n          int
+}
+
+type myStructs []*myStruct
+
+func (s myStructs) Len() int           { return len(s) }
+func (s myStructs) Less(i, j int) bool { return s[i].n < s[j].n }
+func (s myStructs) Swap(i, j int)      { s[i], s[j] = s[j], s[i] }
+
+func makeRandomStructs(n int) myStructs {
+	rand.Seed(42)
+	structs := make([]*myStruct, n)
+	for i := 0; i < n; i++ {
+		structs[i] = &myStruct{n: rand.Intn(n)}
+	}
+	return structs
+}
+
+func TestStructSorts(t *testing.T) {
+	ss := makeRandomStructs(200)
+	ss2 := make([]*myStruct, len(ss))
+	for i := range ss {
+		ss2[i] = &myStruct{n: ss[i].n}
+	}
+
+	sort.Sort(ss)
+	SortFunc(ss2, func(a, b *myStruct) int { return a.n - b.n })
+
+	for i := range ss {
+		if *ss[i] != *ss2[i] {
+			t.Fatalf("ints2 mismatch at %d; %v != %v", i, *ss[i], *ss2[i])
+		}
+	}
+}
+
+func BenchmarkSortStructs(b *testing.B) {
+	for i := 0; i < b.N; i++ {
+		b.StopTimer()
+		ss := makeRandomStructs(N)
+		b.StartTimer()
+		sort.Sort(ss)
+	}
+}
+
+func BenchmarkSortFuncStructs(b *testing.B) {
+	cmpFunc := func(a, b *myStruct) int { return a.n - b.n }
+	for i := 0; i < b.N; i++ {
+		b.StopTimer()
+		ss := makeRandomStructs(N)
+		b.StartTimer()
+		SortFunc(ss, cmpFunc)
+	}
+}
+
+func BenchmarkBinarySearchFloats(b *testing.B) {
+	for _, size := range []int{16, 32, 64, 128, 512, 1024} {
+		b.Run(fmt.Sprintf("Size%d", size), func(b *testing.B) {
+			floats := make([]float64, size)
+			for i := range floats {
+				floats[i] = float64(i)
+			}
+			midpoint := len(floats) / 2
+			needle := (floats[midpoint] + floats[midpoint+1]) / 2
+			b.ResetTimer()
+			for i := 0; i < b.N; i++ {
+				BinarySearch(floats, needle)
+			}
+		})
+	}
+}
+
+func BenchmarkBinarySearchFuncStruct(b *testing.B) {
+	for _, size := range []int{16, 32, 64, 128, 512, 1024} {
+		b.Run(fmt.Sprintf("Size%d", size), func(b *testing.B) {
+			structs := make([]*myStruct, size)
+			for i := range structs {
+				structs[i] = &myStruct{n: i}
+			}
+			midpoint := len(structs) / 2
+			needle := &myStruct{n: (structs[midpoint].n + structs[midpoint+1].n) / 2}
+			lessFunc := func(a, b *myStruct) int { return a.n - b.n }
+			b.ResetTimer()
+			for i := 0; i < b.N; i++ {
+				BinarySearchFunc(structs, needle, lessFunc)
+			}
+		})
+	}
+}
diff --color -urN a/vendor/slices/sort_test.go b/vendor/slices/sort_test.go
--- a/vendor/slices/sort_test.go	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/slices/sort_test.go	2024-01-07 22:37:23.162035574 +0800
@@ -0,0 +1,442 @@
+// Copyright 2023 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package slices
+
+import (
+	"cmp"
+	"fmt"
+	"math"
+	"math/rand"
+	"sort"
+	"strconv"
+	"strings"
+	"testing"
+)
+
+var ints = [...]int{74, 59, 238, -784, 9845, 959, 905, 0, 0, 42, 7586, -5467984, 7586}
+var float64s = [...]float64{74.3, 59.0, math.Inf(1), 238.2, -784.0, 2.3, math.Inf(-1), 9845.768, -959.7485, 905, 7.8, 7.8, 74.3, 59.0, math.Inf(1), 238.2, -784.0, 2.3}
+var float64sWithNaNs = [...]float64{74.3, 59.0, math.Inf(1), 238.2, -784.0, 2.3, math.NaN(), math.NaN(), math.Inf(-1), 9845.768, -959.7485, 905, 7.8, 7.8}
+var strs = [...]string{"", "Hello", "foo", "bar", "foo", "f00", "%*&^*&^&", "***"}
+
+func TestSortIntSlice(t *testing.T) {
+	data := Clone(ints[:])
+	Sort(data)
+	if !IsSorted(data) {
+		t.Errorf("sorted %v", ints)
+		t.Errorf("   got %v", data)
+	}
+}
+
+func TestSortFuncIntSlice(t *testing.T) {
+	data := Clone(ints[:])
+	SortFunc(data, func(a, b int) int { return a - b })
+	if !IsSorted(data) {
+		t.Errorf("sorted %v", ints)
+		t.Errorf("   got %v", data)
+	}
+}
+
+func TestSortFloat64Slice(t *testing.T) {
+	data := Clone(float64s[:])
+	Sort(data)
+	if !IsSorted(data) {
+		t.Errorf("sorted %v", float64s)
+		t.Errorf("   got %v", data)
+	}
+}
+
+func TestSortFloat64SliceWithNaNs(t *testing.T) {
+	data := float64sWithNaNs[:]
+	data2 := Clone(data)
+
+	Sort(data)
+	sort.Float64s(data2)
+
+	if !IsSorted(data) {
+		t.Error("IsSorted indicates data isn't sorted")
+	}
+
+	// Compare for equality using cmp.Compare, which considers NaNs equal.
+	if !EqualFunc(data, data2, func(a, b float64) bool { return cmp.Compare(a, b) == 0 }) {
+		t.Errorf("mismatch between Sort and sort.Float64: got %v, want %v", data, data2)
+	}
+}
+
+func TestSortStringSlice(t *testing.T) {
+	data := Clone(strs[:])
+	Sort(data)
+	if !IsSorted(data) {
+		t.Errorf("sorted %v", strs)
+		t.Errorf("   got %v", data)
+	}
+}
+
+func TestSortLarge_Random(t *testing.T) {
+	n := 1000000
+	if testing.Short() {
+		n /= 100
+	}
+	data := make([]int, n)
+	for i := 0; i < len(data); i++ {
+		data[i] = rand.Intn(100)
+	}
+	if IsSorted(data) {
+		t.Fatalf("terrible rand.rand")
+	}
+	Sort(data)
+	if !IsSorted(data) {
+		t.Errorf("sort didn't sort - 1M ints")
+	}
+}
+
+type intPair struct {
+	a, b int
+}
+
+type intPairs []intPair
+
+// Pairs compare on a only.
+func intPairCmp(x, y intPair) int {
+	return x.a - y.a
+}
+
+// Record initial order in B.
+func (d intPairs) initB() {
+	for i := range d {
+		d[i].b = i
+	}
+}
+
+// InOrder checks if a-equal elements were not reordered.
+func (d intPairs) inOrder() bool {
+	lastA, lastB := -1, 0
+	for i := 0; i < len(d); i++ {
+		if lastA != d[i].a {
+			lastA = d[i].a
+			lastB = d[i].b
+			continue
+		}
+		if d[i].b <= lastB {
+			return false
+		}
+		lastB = d[i].b
+	}
+	return true
+}
+
+func TestStability(t *testing.T) {
+	n, m := 100000, 1000
+	if testing.Short() {
+		n, m = 1000, 100
+	}
+	data := make(intPairs, n)
+
+	// random distribution
+	for i := 0; i < len(data); i++ {
+		data[i].a = rand.Intn(m)
+	}
+	if IsSortedFunc(data, intPairCmp) {
+		t.Fatalf("terrible rand.rand")
+	}
+	data.initB()
+	SortStableFunc(data, intPairCmp)
+	if !IsSortedFunc(data, intPairCmp) {
+		t.Errorf("Stable didn't sort %d ints", n)
+	}
+	if !data.inOrder() {
+		t.Errorf("Stable wasn't stable on %d ints", n)
+	}
+
+	// already sorted
+	data.initB()
+	SortStableFunc(data, intPairCmp)
+	if !IsSortedFunc(data, intPairCmp) {
+		t.Errorf("Stable shuffled sorted %d ints (order)", n)
+	}
+	if !data.inOrder() {
+		t.Errorf("Stable shuffled sorted %d ints (stability)", n)
+	}
+
+	// sorted reversed
+	for i := 0; i < len(data); i++ {
+		data[i].a = len(data) - i
+	}
+	data.initB()
+	SortStableFunc(data, intPairCmp)
+	if !IsSortedFunc(data, intPairCmp) {
+		t.Errorf("Stable didn't sort %d ints", n)
+	}
+	if !data.inOrder() {
+		t.Errorf("Stable wasn't stable on %d ints", n)
+	}
+}
+
+type S struct {
+	a int
+	b string
+}
+
+func cmpS(s1, s2 S) int {
+	return cmp.Compare(s1.a, s2.a)
+}
+
+func TestMinMax(t *testing.T) {
+	intCmp := func(a, b int) int { return a - b }
+
+	tests := []struct {
+		data    []int
+		wantMin int
+		wantMax int
+	}{
+		{[]int{7}, 7, 7},
+		{[]int{1, 2}, 1, 2},
+		{[]int{2, 1}, 1, 2},
+		{[]int{1, 2, 3}, 1, 3},
+		{[]int{3, 2, 1}, 1, 3},
+		{[]int{2, 1, 3}, 1, 3},
+		{[]int{2, 2, 3}, 2, 3},
+		{[]int{3, 2, 3}, 2, 3},
+		{[]int{0, 2, -9}, -9, 2},
+	}
+	for _, tt := range tests {
+		t.Run(fmt.Sprintf("%v", tt.data), func(t *testing.T) {
+			gotMin := Min(tt.data)
+			if gotMin != tt.wantMin {
+				t.Errorf("Min got %v, want %v", gotMin, tt.wantMin)
+			}
+
+			gotMinFunc := MinFunc(tt.data, intCmp)
+			if gotMinFunc != tt.wantMin {
+				t.Errorf("MinFunc got %v, want %v", gotMinFunc, tt.wantMin)
+			}
+
+			gotMax := Max(tt.data)
+			if gotMax != tt.wantMax {
+				t.Errorf("Max got %v, want %v", gotMax, tt.wantMax)
+			}
+
+			gotMaxFunc := MaxFunc(tt.data, intCmp)
+			if gotMaxFunc != tt.wantMax {
+				t.Errorf("MaxFunc got %v, want %v", gotMaxFunc, tt.wantMax)
+			}
+		})
+	}
+
+	svals := []S{
+		{1, "a"},
+		{2, "a"},
+		{1, "b"},
+		{2, "b"},
+	}
+
+	gotMin := MinFunc(svals, cmpS)
+	wantMin := S{1, "a"}
+	if gotMin != wantMin {
+		t.Errorf("MinFunc(%v) = %v, want %v", svals, gotMin, wantMin)
+	}
+
+	gotMax := MaxFunc(svals, cmpS)
+	wantMax := S{2, "a"}
+	if gotMax != wantMax {
+		t.Errorf("MaxFunc(%v) = %v, want %v", svals, gotMax, wantMax)
+	}
+}
+
+func TestMinMaxNaNs(t *testing.T) {
+	fs := []float64{1.0, 999.9, 3.14, -400.4, -5.14}
+	if Min(fs) != -400.4 {
+		t.Errorf("got min %v, want -400.4", Min(fs))
+	}
+	if Max(fs) != 999.9 {
+		t.Errorf("got max %v, want 999.9", Max(fs))
+	}
+
+	// No matter which element of fs is replaced with a NaN, both Min and Max
+	// should propagate the NaN to their output.
+	for i := 0; i < len(fs); i++ {
+		testfs := Clone(fs)
+		testfs[i] = math.NaN()
+
+		fmin := Min(testfs)
+		if !math.IsNaN(fmin) {
+			t.Errorf("got min %v, want NaN", fmin)
+		}
+
+		fmax := Max(testfs)
+		if !math.IsNaN(fmax) {
+			t.Errorf("got max %v, want NaN", fmax)
+		}
+	}
+}
+
+func TestMinMaxPanics(t *testing.T) {
+	intCmp := func(a, b int) int { return a - b }
+	emptySlice := []int{}
+
+	if !panics(func() { Min(emptySlice) }) {
+		t.Errorf("Min([]): got no panic, want panic")
+	}
+
+	if !panics(func() { Max(emptySlice) }) {
+		t.Errorf("Max([]): got no panic, want panic")
+	}
+
+	if !panics(func() { MinFunc(emptySlice, intCmp) }) {
+		t.Errorf("MinFunc([]): got no panic, want panic")
+	}
+
+	if !panics(func() { MaxFunc(emptySlice, intCmp) }) {
+		t.Errorf("MaxFunc([]): got no panic, want panic")
+	}
+}
+
+func TestBinarySearch(t *testing.T) {
+	str1 := []string{"foo"}
+	str2 := []string{"ab", "ca"}
+	str3 := []string{"mo", "qo", "vo"}
+	str4 := []string{"ab", "ad", "ca", "xy"}
+
+	// slice with repeating elements
+	strRepeats := []string{"ba", "ca", "da", "da", "da", "ka", "ma", "ma", "ta"}
+
+	// slice with all element equal
+	strSame := []string{"xx", "xx", "xx"}
+
+	tests := []struct {
+		data      []string
+		target    string
+		wantPos   int
+		wantFound bool
+	}{
+		{[]string{}, "foo", 0, false},
+		{[]string{}, "", 0, false},
+
+		{str1, "foo", 0, true},
+		{str1, "bar", 0, false},
+		{str1, "zx", 1, false},
+
+		{str2, "aa", 0, false},
+		{str2, "ab", 0, true},
+		{str2, "ad", 1, false},
+		{str2, "ca", 1, true},
+		{str2, "ra", 2, false},
+
+		{str3, "bb", 0, false},
+		{str3, "mo", 0, true},
+		{str3, "nb", 1, false},
+		{str3, "qo", 1, true},
+		{str3, "tr", 2, false},
+		{str3, "vo", 2, true},
+		{str3, "xr", 3, false},
+
+		{str4, "aa", 0, false},
+		{str4, "ab", 0, true},
+		{str4, "ac", 1, false},
+		{str4, "ad", 1, true},
+		{str4, "ax", 2, false},
+		{str4, "ca", 2, true},
+		{str4, "cc", 3, false},
+		{str4, "dd", 3, false},
+		{str4, "xy", 3, true},
+		{str4, "zz", 4, false},
+
+		{strRepeats, "da", 2, true},
+		{strRepeats, "db", 5, false},
+		{strRepeats, "ma", 6, true},
+		{strRepeats, "mb", 8, false},
+
+		{strSame, "xx", 0, true},
+		{strSame, "ab", 0, false},
+		{strSame, "zz", 3, false},
+	}
+	for _, tt := range tests {
+		t.Run(tt.target, func(t *testing.T) {
+			{
+				pos, found := BinarySearch(tt.data, tt.target)
+				if pos != tt.wantPos || found != tt.wantFound {
+					t.Errorf("BinarySearch got (%v, %v), want (%v, %v)", pos, found, tt.wantPos, tt.wantFound)
+				}
+			}
+
+			{
+				pos, found := BinarySearchFunc(tt.data, tt.target, strings.Compare)
+				if pos != tt.wantPos || found != tt.wantFound {
+					t.Errorf("BinarySearchFunc got (%v, %v), want (%v, %v)", pos, found, tt.wantPos, tt.wantFound)
+				}
+			}
+		})
+	}
+}
+
+func TestBinarySearchInts(t *testing.T) {
+	data := []int{20, 30, 40, 50, 60, 70, 80, 90}
+	tests := []struct {
+		target    int
+		wantPos   int
+		wantFound bool
+	}{
+		{20, 0, true},
+		{23, 1, false},
+		{43, 3, false},
+		{80, 6, true},
+	}
+	for _, tt := range tests {
+		t.Run(strconv.Itoa(tt.target), func(t *testing.T) {
+			{
+				pos, found := BinarySearch(data, tt.target)
+				if pos != tt.wantPos || found != tt.wantFound {
+					t.Errorf("BinarySearch got (%v, %v), want (%v, %v)", pos, found, tt.wantPos, tt.wantFound)
+				}
+			}
+
+			{
+				cmp := func(a, b int) int {
+					return a - b
+				}
+				pos, found := BinarySearchFunc(data, tt.target, cmp)
+				if pos != tt.wantPos || found != tt.wantFound {
+					t.Errorf("BinarySearchFunc got (%v, %v), want (%v, %v)", pos, found, tt.wantPos, tt.wantFound)
+				}
+			}
+		})
+	}
+}
+
+func TestBinarySearchFloats(t *testing.T) {
+	data := []float64{math.NaN(), -0.25, 0.0, 1.4}
+	tests := []struct {
+		target    float64
+		wantPos   int
+		wantFound bool
+	}{
+		{math.NaN(), 0, true},
+		{math.Inf(-1), 1, false},
+		{-0.25, 1, true},
+		{0.0, 2, true},
+		{1.4, 3, true},
+		{1.5, 4, false},
+	}
+	for _, tt := range tests {
+		t.Run(fmt.Sprintf("%v", tt.target), func(t *testing.T) {
+			{
+				pos, found := BinarySearch(data, tt.target)
+				if pos != tt.wantPos || found != tt.wantFound {
+					t.Errorf("BinarySearch got (%v, %v), want (%v, %v)", pos, found, tt.wantPos, tt.wantFound)
+				}
+			}
+		})
+	}
+}
+
+func TestBinarySearchFunc(t *testing.T) {
+	data := []int{1, 10, 11, 2} // sorted lexicographically
+	cmp := func(a int, b string) int {
+		return strings.Compare(strconv.Itoa(a), b)
+	}
+	pos, found := BinarySearchFunc(data, "2", cmp)
+	if pos != 3 || !found {
+		t.Errorf("BinarySearchFunc(%v, %q, cmp) = %v, %v, want %v, %v", data, "2", pos, found, 3, true)
+	}
+}
diff --color -urN a/vendor/slices/zsortanyfunc.go b/vendor/slices/zsortanyfunc.go
--- a/vendor/slices/zsortanyfunc.go	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/slices/zsortanyfunc.go	2024-01-07 22:37:23.162035574 +0800
@@ -0,0 +1,479 @@
+// Code generated by gen_sort_variants.go; DO NOT EDIT.
+
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package slices
+
+// insertionSortCmpFunc sorts data[a:b] using insertion sort.
+func insertionSortCmpFunc[E any](data []E, a, b int, cmp func(a, b E) int) {
+	for i := a + 1; i < b; i++ {
+		for j := i; j > a && (cmp(data[j], data[j-1]) < 0); j-- {
+			data[j], data[j-1] = data[j-1], data[j]
+		}
+	}
+}
+
+// siftDownCmpFunc implements the heap property on data[lo:hi].
+// first is an offset into the array where the root of the heap lies.
+func siftDownCmpFunc[E any](data []E, lo, hi, first int, cmp func(a, b E) int) {
+	root := lo
+	for {
+		child := 2*root + 1
+		if child >= hi {
+			break
+		}
+		if child+1 < hi && (cmp(data[first+child], data[first+child+1]) < 0) {
+			child++
+		}
+		if !(cmp(data[first+root], data[first+child]) < 0) {
+			return
+		}
+		data[first+root], data[first+child] = data[first+child], data[first+root]
+		root = child
+	}
+}
+
+func heapSortCmpFunc[E any](data []E, a, b int, cmp func(a, b E) int) {
+	first := a
+	lo := 0
+	hi := b - a
+
+	// Build heap with greatest element at top.
+	for i := (hi - 1) / 2; i >= 0; i-- {
+		siftDownCmpFunc(data, i, hi, first, cmp)
+	}
+
+	// Pop elements, largest first, into end of data.
+	for i := hi - 1; i >= 0; i-- {
+		data[first], data[first+i] = data[first+i], data[first]
+		siftDownCmpFunc(data, lo, i, first, cmp)
+	}
+}
+
+// pdqsortCmpFunc sorts data[a:b].
+// The algorithm based on pattern-defeating quicksort(pdqsort), but without the optimizations from BlockQuicksort.
+// pdqsort paper: https://arxiv.org/pdf/2106.05123.pdf
+// C++ implementation: https://github.com/orlp/pdqsort
+// Rust implementation: https://docs.rs/pdqsort/latest/pdqsort/
+// limit is the number of allowed bad (very unbalanced) pivots before falling back to heapsort.
+func pdqsortCmpFunc[E any](data []E, a, b, limit int, cmp func(a, b E) int) {
+	const maxInsertion = 12
+
+	var (
+		wasBalanced    = true // whether the last partitioning was reasonably balanced
+		wasPartitioned = true // whether the slice was already partitioned
+	)
+
+	for {
+		length := b - a
+
+		if length <= maxInsertion {
+			insertionSortCmpFunc(data, a, b, cmp)
+			return
+		}
+
+		// Fall back to heapsort if too many bad choices were made.
+		if limit == 0 {
+			heapSortCmpFunc(data, a, b, cmp)
+			return
+		}
+
+		// If the last partitioning was imbalanced, we need to breaking patterns.
+		if !wasBalanced {
+			breakPatternsCmpFunc(data, a, b, cmp)
+			limit--
+		}
+
+		pivot, hint := choosePivotCmpFunc(data, a, b, cmp)
+		if hint == decreasingHint {
+			reverseRangeCmpFunc(data, a, b, cmp)
+			// The chosen pivot was pivot-a elements after the start of the array.
+			// After reversing it is pivot-a elements before the end of the array.
+			// The idea came from Rust's implementation.
+			pivot = (b - 1) - (pivot - a)
+			hint = increasingHint
+		}
+
+		// The slice is likely already sorted.
+		if wasBalanced && wasPartitioned && hint == increasingHint {
+			if partialInsertionSortCmpFunc(data, a, b, cmp) {
+				return
+			}
+		}
+
+		// Probably the slice contains many duplicate elements, partition the slice into
+		// elements equal to and elements greater than the pivot.
+		if a > 0 && !(cmp(data[a-1], data[pivot]) < 0) {
+			mid := partitionEqualCmpFunc(data, a, b, pivot, cmp)
+			a = mid
+			continue
+		}
+
+		mid, alreadyPartitioned := partitionCmpFunc(data, a, b, pivot, cmp)
+		wasPartitioned = alreadyPartitioned
+
+		leftLen, rightLen := mid-a, b-mid
+		balanceThreshold := length / 8
+		if leftLen < rightLen {
+			wasBalanced = leftLen >= balanceThreshold
+			pdqsortCmpFunc(data, a, mid, limit, cmp)
+			a = mid + 1
+		} else {
+			wasBalanced = rightLen >= balanceThreshold
+			pdqsortCmpFunc(data, mid+1, b, limit, cmp)
+			b = mid
+		}
+	}
+}
+
+// partitionCmpFunc does one quicksort partition.
+// Let p = data[pivot]
+// Moves elements in data[a:b] around, so that data[i]<p and data[j]>=p for i<newpivot and j>newpivot.
+// On return, data[newpivot] = p
+func partitionCmpFunc[E any](data []E, a, b, pivot int, cmp func(a, b E) int) (newpivot int, alreadyPartitioned bool) {
+	data[a], data[pivot] = data[pivot], data[a]
+	i, j := a+1, b-1 // i and j are inclusive of the elements remaining to be partitioned
+
+	for i <= j && (cmp(data[i], data[a]) < 0) {
+		i++
+	}
+	for i <= j && !(cmp(data[j], data[a]) < 0) {
+		j--
+	}
+	if i > j {
+		data[j], data[a] = data[a], data[j]
+		return j, true
+	}
+	data[i], data[j] = data[j], data[i]
+	i++
+	j--
+
+	for {
+		for i <= j && (cmp(data[i], data[a]) < 0) {
+			i++
+		}
+		for i <= j && !(cmp(data[j], data[a]) < 0) {
+			j--
+		}
+		if i > j {
+			break
+		}
+		data[i], data[j] = data[j], data[i]
+		i++
+		j--
+	}
+	data[j], data[a] = data[a], data[j]
+	return j, false
+}
+
+// partitionEqualCmpFunc partitions data[a:b] into elements equal to data[pivot] followed by elements greater than data[pivot].
+// It assumed that data[a:b] does not contain elements smaller than the data[pivot].
+func partitionEqualCmpFunc[E any](data []E, a, b, pivot int, cmp func(a, b E) int) (newpivot int) {
+	data[a], data[pivot] = data[pivot], data[a]
+	i, j := a+1, b-1 // i and j are inclusive of the elements remaining to be partitioned
+
+	for {
+		for i <= j && !(cmp(data[a], data[i]) < 0) {
+			i++
+		}
+		for i <= j && (cmp(data[a], data[j]) < 0) {
+			j--
+		}
+		if i > j {
+			break
+		}
+		data[i], data[j] = data[j], data[i]
+		i++
+		j--
+	}
+	return i
+}
+
+// partialInsertionSortCmpFunc partially sorts a slice, returns true if the slice is sorted at the end.
+func partialInsertionSortCmpFunc[E any](data []E, a, b int, cmp func(a, b E) int) bool {
+	const (
+		maxSteps         = 5  // maximum number of adjacent out-of-order pairs that will get shifted
+		shortestShifting = 50 // don't shift any elements on short arrays
+	)
+	i := a + 1
+	for j := 0; j < maxSteps; j++ {
+		for i < b && !(cmp(data[i], data[i-1]) < 0) {
+			i++
+		}
+
+		if i == b {
+			return true
+		}
+
+		if b-a < shortestShifting {
+			return false
+		}
+
+		data[i], data[i-1] = data[i-1], data[i]
+
+		// Shift the smaller one to the left.
+		if i-a >= 2 {
+			for j := i - 1; j >= 1; j-- {
+				if !(cmp(data[j], data[j-1]) < 0) {
+					break
+				}
+				data[j], data[j-1] = data[j-1], data[j]
+			}
+		}
+		// Shift the greater one to the right.
+		if b-i >= 2 {
+			for j := i + 1; j < b; j++ {
+				if !(cmp(data[j], data[j-1]) < 0) {
+					break
+				}
+				data[j], data[j-1] = data[j-1], data[j]
+			}
+		}
+	}
+	return false
+}
+
+// breakPatternsCmpFunc scatters some elements around in an attempt to break some patterns
+// that might cause imbalanced partitions in quicksort.
+func breakPatternsCmpFunc[E any](data []E, a, b int, cmp func(a, b E) int) {
+	length := b - a
+	if length >= 8 {
+		random := xorshift(length)
+		modulus := nextPowerOfTwo(length)
+
+		for idx := a + (length/4)*2 - 1; idx <= a+(length/4)*2+1; idx++ {
+			other := int(uint(random.Next()) & (modulus - 1))
+			if other >= length {
+				other -= length
+			}
+			data[idx], data[a+other] = data[a+other], data[idx]
+		}
+	}
+}
+
+// choosePivotCmpFunc chooses a pivot in data[a:b].
+//
+// [0,8): chooses a static pivot.
+// [8,shortestNinther): uses the simple median-of-three method.
+// [shortestNinther,∞): uses the Tukey ninther method.
+func choosePivotCmpFunc[E any](data []E, a, b int, cmp func(a, b E) int) (pivot int, hint sortedHint) {
+	const (
+		shortestNinther = 50
+		maxSwaps        = 4 * 3
+	)
+
+	l := b - a
+
+	var (
+		swaps int
+		i     = a + l/4*1
+		j     = a + l/4*2
+		k     = a + l/4*3
+	)
+
+	if l >= 8 {
+		if l >= shortestNinther {
+			// Tukey ninther method, the idea came from Rust's implementation.
+			i = medianAdjacentCmpFunc(data, i, &swaps, cmp)
+			j = medianAdjacentCmpFunc(data, j, &swaps, cmp)
+			k = medianAdjacentCmpFunc(data, k, &swaps, cmp)
+		}
+		// Find the median among i, j, k and stores it into j.
+		j = medianCmpFunc(data, i, j, k, &swaps, cmp)
+	}
+
+	switch swaps {
+	case 0:
+		return j, increasingHint
+	case maxSwaps:
+		return j, decreasingHint
+	default:
+		return j, unknownHint
+	}
+}
+
+// order2CmpFunc returns x,y where data[x] <= data[y], where x,y=a,b or x,y=b,a.
+func order2CmpFunc[E any](data []E, a, b int, swaps *int, cmp func(a, b E) int) (int, int) {
+	if cmp(data[b], data[a]) < 0 {
+		*swaps++
+		return b, a
+	}
+	return a, b
+}
+
+// medianCmpFunc returns x where data[x] is the median of data[a],data[b],data[c], where x is a, b, or c.
+func medianCmpFunc[E any](data []E, a, b, c int, swaps *int, cmp func(a, b E) int) int {
+	a, b = order2CmpFunc(data, a, b, swaps, cmp)
+	b, c = order2CmpFunc(data, b, c, swaps, cmp)
+	a, b = order2CmpFunc(data, a, b, swaps, cmp)
+	return b
+}
+
+// medianAdjacentCmpFunc finds the median of data[a - 1], data[a], data[a + 1] and stores the index into a.
+func medianAdjacentCmpFunc[E any](data []E, a int, swaps *int, cmp func(a, b E) int) int {
+	return medianCmpFunc(data, a-1, a, a+1, swaps, cmp)
+}
+
+func reverseRangeCmpFunc[E any](data []E, a, b int, cmp func(a, b E) int) {
+	i := a
+	j := b - 1
+	for i < j {
+		data[i], data[j] = data[j], data[i]
+		i++
+		j--
+	}
+}
+
+func swapRangeCmpFunc[E any](data []E, a, b, n int, cmp func(a, b E) int) {
+	for i := 0; i < n; i++ {
+		data[a+i], data[b+i] = data[b+i], data[a+i]
+	}
+}
+
+func stableCmpFunc[E any](data []E, n int, cmp func(a, b E) int) {
+	blockSize := 20 // must be > 0
+	a, b := 0, blockSize
+	for b <= n {
+		insertionSortCmpFunc(data, a, b, cmp)
+		a = b
+		b += blockSize
+	}
+	insertionSortCmpFunc(data, a, n, cmp)
+
+	for blockSize < n {
+		a, b = 0, 2*blockSize
+		for b <= n {
+			symMergeCmpFunc(data, a, a+blockSize, b, cmp)
+			a = b
+			b += 2 * blockSize
+		}
+		if m := a + blockSize; m < n {
+			symMergeCmpFunc(data, a, m, n, cmp)
+		}
+		blockSize *= 2
+	}
+}
+
+// symMergeCmpFunc merges the two sorted subsequences data[a:m] and data[m:b] using
+// the SymMerge algorithm from Pok-Son Kim and Arne Kutzner, "Stable Minimum
+// Storage Merging by Symmetric Comparisons", in Susanne Albers and Tomasz
+// Radzik, editors, Algorithms - ESA 2004, volume 3221 of Lecture Notes in
+// Computer Science, pages 714-723. Springer, 2004.
+//
+// Let M = m-a and N = b-n. Wolog M < N.
+// The recursion depth is bound by ceil(log(N+M)).
+// The algorithm needs O(M*log(N/M + 1)) calls to data.Less.
+// The algorithm needs O((M+N)*log(M)) calls to data.Swap.
+//
+// The paper gives O((M+N)*log(M)) as the number of assignments assuming a
+// rotation algorithm which uses O(M+N+gcd(M+N)) assignments. The argumentation
+// in the paper carries through for Swap operations, especially as the block
+// swapping rotate uses only O(M+N) Swaps.
+//
+// symMerge assumes non-degenerate arguments: a < m && m < b.
+// Having the caller check this condition eliminates many leaf recursion calls,
+// which improves performance.
+func symMergeCmpFunc[E any](data []E, a, m, b int, cmp func(a, b E) int) {
+	// Avoid unnecessary recursions of symMerge
+	// by direct insertion of data[a] into data[m:b]
+	// if data[a:m] only contains one element.
+	if m-a == 1 {
+		// Use binary search to find the lowest index i
+		// such that data[i] >= data[a] for m <= i < b.
+		// Exit the search loop with i == b in case no such index exists.
+		i := m
+		j := b
+		for i < j {
+			h := int(uint(i+j) >> 1)
+			if cmp(data[h], data[a]) < 0 {
+				i = h + 1
+			} else {
+				j = h
+			}
+		}
+		// Swap values until data[a] reaches the position before i.
+		for k := a; k < i-1; k++ {
+			data[k], data[k+1] = data[k+1], data[k]
+		}
+		return
+	}
+
+	// Avoid unnecessary recursions of symMerge
+	// by direct insertion of data[m] into data[a:m]
+	// if data[m:b] only contains one element.
+	if b-m == 1 {
+		// Use binary search to find the lowest index i
+		// such that data[i] > data[m] for a <= i < m.
+		// Exit the search loop with i == m in case no such index exists.
+		i := a
+		j := m
+		for i < j {
+			h := int(uint(i+j) >> 1)
+			if !(cmp(data[m], data[h]) < 0) {
+				i = h + 1
+			} else {
+				j = h
+			}
+		}
+		// Swap values until data[m] reaches the position i.
+		for k := m; k > i; k-- {
+			data[k], data[k-1] = data[k-1], data[k]
+		}
+		return
+	}
+
+	mid := int(uint(a+b) >> 1)
+	n := mid + m
+	var start, r int
+	if m > mid {
+		start = n - b
+		r = mid
+	} else {
+		start = a
+		r = m
+	}
+	p := n - 1
+
+	for start < r {
+		c := int(uint(start+r) >> 1)
+		if !(cmp(data[p-c], data[c]) < 0) {
+			start = c + 1
+		} else {
+			r = c
+		}
+	}
+
+	end := n - start
+	if start < m && m < end {
+		rotateCmpFunc(data, start, m, end, cmp)
+	}
+	if a < start && start < mid {
+		symMergeCmpFunc(data, a, start, mid, cmp)
+	}
+	if mid < end && end < b {
+		symMergeCmpFunc(data, mid, end, b, cmp)
+	}
+}
+
+// rotateCmpFunc rotates two consecutive blocks u = data[a:m] and v = data[m:b] in data:
+// Data of the form 'x u v y' is changed to 'x v u y'.
+// rotate performs at most b-a many calls to data.Swap,
+// and it assumes non-degenerate arguments: a < m && m < b.
+func rotateCmpFunc[E any](data []E, a, m, b int, cmp func(a, b E) int) {
+	i := m - a
+	j := b - m
+
+	for i != j {
+		if i > j {
+			swapRangeCmpFunc(data, m-i, m, j, cmp)
+			i -= j
+		} else {
+			swapRangeCmpFunc(data, m-i, m+j-i, i, cmp)
+			j -= i
+		}
+	}
+	// i == j
+	swapRangeCmpFunc(data, m-i, m, i, cmp)
+}
diff --color -urN a/vendor/slices/zsortordered.go b/vendor/slices/zsortordered.go
--- a/vendor/slices/zsortordered.go	1970-01-01 08:00:00.000000000 +0800
+++ b/vendor/slices/zsortordered.go	2024-01-07 22:37:23.162035574 +0800
@@ -0,0 +1,481 @@
+// Code generated by gen_sort_variants.go; DO NOT EDIT.
+
+// Copyright 2022 The Go Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style
+// license that can be found in the LICENSE file.
+
+package slices
+
+import "cmp"
+
+// insertionSortOrdered sorts data[a:b] using insertion sort.
+func insertionSortOrdered[E cmp.Ordered](data []E, a, b int) {
+	for i := a + 1; i < b; i++ {
+		for j := i; j > a && cmp.Less(data[j], data[j-1]); j-- {
+			data[j], data[j-1] = data[j-1], data[j]
+		}
+	}
+}
+
+// siftDownOrdered implements the heap property on data[lo:hi].
+// first is an offset into the array where the root of the heap lies.
+func siftDownOrdered[E cmp.Ordered](data []E, lo, hi, first int) {
+	root := lo
+	for {
+		child := 2*root + 1
+		if child >= hi {
+			break
+		}
+		if child+1 < hi && cmp.Less(data[first+child], data[first+child+1]) {
+			child++
+		}
+		if !cmp.Less(data[first+root], data[first+child]) {
+			return
+		}
+		data[first+root], data[first+child] = data[first+child], data[first+root]
+		root = child
+	}
+}
+
+func heapSortOrdered[E cmp.Ordered](data []E, a, b int) {
+	first := a
+	lo := 0
+	hi := b - a
+
+	// Build heap with greatest element at top.
+	for i := (hi - 1) / 2; i >= 0; i-- {
+		siftDownOrdered(data, i, hi, first)
+	}
+
+	// Pop elements, largest first, into end of data.
+	for i := hi - 1; i >= 0; i-- {
+		data[first], data[first+i] = data[first+i], data[first]
+		siftDownOrdered(data, lo, i, first)
+	}
+}
+
+// pdqsortOrdered sorts data[a:b].
+// The algorithm based on pattern-defeating quicksort(pdqsort), but without the optimizations from BlockQuicksort.
+// pdqsort paper: https://arxiv.org/pdf/2106.05123.pdf
+// C++ implementation: https://github.com/orlp/pdqsort
+// Rust implementation: https://docs.rs/pdqsort/latest/pdqsort/
+// limit is the number of allowed bad (very unbalanced) pivots before falling back to heapsort.
+func pdqsortOrdered[E cmp.Ordered](data []E, a, b, limit int) {
+	const maxInsertion = 12
+
+	var (
+		wasBalanced    = true // whether the last partitioning was reasonably balanced
+		wasPartitioned = true // whether the slice was already partitioned
+	)
+
+	for {
+		length := b - a
+
+		if length <= maxInsertion {
+			insertionSortOrdered(data, a, b)
+			return
+		}
+
+		// Fall back to heapsort if too many bad choices were made.
+		if limit == 0 {
+			heapSortOrdered(data, a, b)
+			return
+		}
+
+		// If the last partitioning was imbalanced, we need to breaking patterns.
+		if !wasBalanced {
+			breakPatternsOrdered(data, a, b)
+			limit--
+		}
+
+		pivot, hint := choosePivotOrdered(data, a, b)
+		if hint == decreasingHint {
+			reverseRangeOrdered(data, a, b)
+			// The chosen pivot was pivot-a elements after the start of the array.
+			// After reversing it is pivot-a elements before the end of the array.
+			// The idea came from Rust's implementation.
+			pivot = (b - 1) - (pivot - a)
+			hint = increasingHint
+		}
+
+		// The slice is likely already sorted.
+		if wasBalanced && wasPartitioned && hint == increasingHint {
+			if partialInsertionSortOrdered(data, a, b) {
+				return
+			}
+		}
+
+		// Probably the slice contains many duplicate elements, partition the slice into
+		// elements equal to and elements greater than the pivot.
+		if a > 0 && !cmp.Less(data[a-1], data[pivot]) {
+			mid := partitionEqualOrdered(data, a, b, pivot)
+			a = mid
+			continue
+		}
+
+		mid, alreadyPartitioned := partitionOrdered(data, a, b, pivot)
+		wasPartitioned = alreadyPartitioned
+
+		leftLen, rightLen := mid-a, b-mid
+		balanceThreshold := length / 8
+		if leftLen < rightLen {
+			wasBalanced = leftLen >= balanceThreshold
+			pdqsortOrdered(data, a, mid, limit)
+			a = mid + 1
+		} else {
+			wasBalanced = rightLen >= balanceThreshold
+			pdqsortOrdered(data, mid+1, b, limit)
+			b = mid
+		}
+	}
+}
+
+// partitionOrdered does one quicksort partition.
+// Let p = data[pivot]
+// Moves elements in data[a:b] around, so that data[i]<p and data[j]>=p for i<newpivot and j>newpivot.
+// On return, data[newpivot] = p
+func partitionOrdered[E cmp.Ordered](data []E, a, b, pivot int) (newpivot int, alreadyPartitioned bool) {
+	data[a], data[pivot] = data[pivot], data[a]
+	i, j := a+1, b-1 // i and j are inclusive of the elements remaining to be partitioned
+
+	for i <= j && cmp.Less(data[i], data[a]) {
+		i++
+	}
+	for i <= j && !cmp.Less(data[j], data[a]) {
+		j--
+	}
+	if i > j {
+		data[j], data[a] = data[a], data[j]
+		return j, true
+	}
+	data[i], data[j] = data[j], data[i]
+	i++
+	j--
+
+	for {
+		for i <= j && cmp.Less(data[i], data[a]) {
+			i++
+		}
+		for i <= j && !cmp.Less(data[j], data[a]) {
+			j--
+		}
+		if i > j {
+			break
+		}
+		data[i], data[j] = data[j], data[i]
+		i++
+		j--
+	}
+	data[j], data[a] = data[a], data[j]
+	return j, false
+}
+
+// partitionEqualOrdered partitions data[a:b] into elements equal to data[pivot] followed by elements greater than data[pivot].
+// It assumed that data[a:b] does not contain elements smaller than the data[pivot].
+func partitionEqualOrdered[E cmp.Ordered](data []E, a, b, pivot int) (newpivot int) {
+	data[a], data[pivot] = data[pivot], data[a]
+	i, j := a+1, b-1 // i and j are inclusive of the elements remaining to be partitioned
+
+	for {
+		for i <= j && !cmp.Less(data[a], data[i]) {
+			i++
+		}
+		for i <= j && cmp.Less(data[a], data[j]) {
+			j--
+		}
+		if i > j {
+			break
+		}
+		data[i], data[j] = data[j], data[i]
+		i++
+		j--
+	}
+	return i
+}
+
+// partialInsertionSortOrdered partially sorts a slice, returns true if the slice is sorted at the end.
+func partialInsertionSortOrdered[E cmp.Ordered](data []E, a, b int) bool {
+	const (
+		maxSteps         = 5  // maximum number of adjacent out-of-order pairs that will get shifted
+		shortestShifting = 50 // don't shift any elements on short arrays
+	)
+	i := a + 1
+	for j := 0; j < maxSteps; j++ {
+		for i < b && !cmp.Less(data[i], data[i-1]) {
+			i++
+		}
+
+		if i == b {
+			return true
+		}
+
+		if b-a < shortestShifting {
+			return false
+		}
+
+		data[i], data[i-1] = data[i-1], data[i]
+
+		// Shift the smaller one to the left.
+		if i-a >= 2 {
+			for j := i - 1; j >= 1; j-- {
+				if !cmp.Less(data[j], data[j-1]) {
+					break
+				}
+				data[j], data[j-1] = data[j-1], data[j]
+			}
+		}
+		// Shift the greater one to the right.
+		if b-i >= 2 {
+			for j := i + 1; j < b; j++ {
+				if !cmp.Less(data[j], data[j-1]) {
+					break
+				}
+				data[j], data[j-1] = data[j-1], data[j]
+			}
+		}
+	}
+	return false
+}
+
+// breakPatternsOrdered scatters some elements around in an attempt to break some patterns
+// that might cause imbalanced partitions in quicksort.
+func breakPatternsOrdered[E cmp.Ordered](data []E, a, b int) {
+	length := b - a
+	if length >= 8 {
+		random := xorshift(length)
+		modulus := nextPowerOfTwo(length)
+
+		for idx := a + (length/4)*2 - 1; idx <= a+(length/4)*2+1; idx++ {
+			other := int(uint(random.Next()) & (modulus - 1))
+			if other >= length {
+				other -= length
+			}
+			data[idx], data[a+other] = data[a+other], data[idx]
+		}
+	}
+}
+
+// choosePivotOrdered chooses a pivot in data[a:b].
+//
+// [0,8): chooses a static pivot.
+// [8,shortestNinther): uses the simple median-of-three method.
+// [shortestNinther,∞): uses the Tukey ninther method.
+func choosePivotOrdered[E cmp.Ordered](data []E, a, b int) (pivot int, hint sortedHint) {
+	const (
+		shortestNinther = 50
+		maxSwaps        = 4 * 3
+	)
+
+	l := b - a
+
+	var (
+		swaps int
+		i     = a + l/4*1
+		j     = a + l/4*2
+		k     = a + l/4*3
+	)
+
+	if l >= 8 {
+		if l >= shortestNinther {
+			// Tukey ninther method, the idea came from Rust's implementation.
+			i = medianAdjacentOrdered(data, i, &swaps)
+			j = medianAdjacentOrdered(data, j, &swaps)
+			k = medianAdjacentOrdered(data, k, &swaps)
+		}
+		// Find the median among i, j, k and stores it into j.
+		j = medianOrdered(data, i, j, k, &swaps)
+	}
+
+	switch swaps {
+	case 0:
+		return j, increasingHint
+	case maxSwaps:
+		return j, decreasingHint
+	default:
+		return j, unknownHint
+	}
+}
+
+// order2Ordered returns x,y where data[x] <= data[y], where x,y=a,b or x,y=b,a.
+func order2Ordered[E cmp.Ordered](data []E, a, b int, swaps *int) (int, int) {
+	if cmp.Less(data[b], data[a]) {
+		*swaps++
+		return b, a
+	}
+	return a, b
+}
+
+// medianOrdered returns x where data[x] is the median of data[a],data[b],data[c], where x is a, b, or c.
+func medianOrdered[E cmp.Ordered](data []E, a, b, c int, swaps *int) int {
+	a, b = order2Ordered(data, a, b, swaps)
+	b, c = order2Ordered(data, b, c, swaps)
+	a, b = order2Ordered(data, a, b, swaps)
+	return b
+}
+
+// medianAdjacentOrdered finds the median of data[a - 1], data[a], data[a + 1] and stores the index into a.
+func medianAdjacentOrdered[E cmp.Ordered](data []E, a int, swaps *int) int {
+	return medianOrdered(data, a-1, a, a+1, swaps)
+}
+
+func reverseRangeOrdered[E cmp.Ordered](data []E, a, b int) {
+	i := a
+	j := b - 1
+	for i < j {
+		data[i], data[j] = data[j], data[i]
+		i++
+		j--
+	}
+}
+
+func swapRangeOrdered[E cmp.Ordered](data []E, a, b, n int) {
+	for i := 0; i < n; i++ {
+		data[a+i], data[b+i] = data[b+i], data[a+i]
+	}
+}
+
+func stableOrdered[E cmp.Ordered](data []E, n int) {
+	blockSize := 20 // must be > 0
+	a, b := 0, blockSize
+	for b <= n {
+		insertionSortOrdered(data, a, b)
+		a = b
+		b += blockSize
+	}
+	insertionSortOrdered(data, a, n)
+
+	for blockSize < n {
+		a, b = 0, 2*blockSize
+		for b <= n {
+			symMergeOrdered(data, a, a+blockSize, b)
+			a = b
+			b += 2 * blockSize
+		}
+		if m := a + blockSize; m < n {
+			symMergeOrdered(data, a, m, n)
+		}
+		blockSize *= 2
+	}
+}
+
+// symMergeOrdered merges the two sorted subsequences data[a:m] and data[m:b] using
+// the SymMerge algorithm from Pok-Son Kim and Arne Kutzner, "Stable Minimum
+// Storage Merging by Symmetric Comparisons", in Susanne Albers and Tomasz
+// Radzik, editors, Algorithms - ESA 2004, volume 3221 of Lecture Notes in
+// Computer Science, pages 714-723. Springer, 2004.
+//
+// Let M = m-a and N = b-n. Wolog M < N.
+// The recursion depth is bound by ceil(log(N+M)).
+// The algorithm needs O(M*log(N/M + 1)) calls to data.Less.
+// The algorithm needs O((M+N)*log(M)) calls to data.Swap.
+//
+// The paper gives O((M+N)*log(M)) as the number of assignments assuming a
+// rotation algorithm which uses O(M+N+gcd(M+N)) assignments. The argumentation
+// in the paper carries through for Swap operations, especially as the block
+// swapping rotate uses only O(M+N) Swaps.
+//
+// symMerge assumes non-degenerate arguments: a < m && m < b.
+// Having the caller check this condition eliminates many leaf recursion calls,
+// which improves performance.
+func symMergeOrdered[E cmp.Ordered](data []E, a, m, b int) {
+	// Avoid unnecessary recursions of symMerge
+	// by direct insertion of data[a] into data[m:b]
+	// if data[a:m] only contains one element.
+	if m-a == 1 {
+		// Use binary search to find the lowest index i
+		// such that data[i] >= data[a] for m <= i < b.
+		// Exit the search loop with i == b in case no such index exists.
+		i := m
+		j := b
+		for i < j {
+			h := int(uint(i+j) >> 1)
+			if cmp.Less(data[h], data[a]) {
+				i = h + 1
+			} else {
+				j = h
+			}
+		}
+		// Swap values until data[a] reaches the position before i.
+		for k := a; k < i-1; k++ {
+			data[k], data[k+1] = data[k+1], data[k]
+		}
+		return
+	}
+
+	// Avoid unnecessary recursions of symMerge
+	// by direct insertion of data[m] into data[a:m]
+	// if data[m:b] only contains one element.
+	if b-m == 1 {
+		// Use binary search to find the lowest index i
+		// such that data[i] > data[m] for a <= i < m.
+		// Exit the search loop with i == m in case no such index exists.
+		i := a
+		j := m
+		for i < j {
+			h := int(uint(i+j) >> 1)
+			if !cmp.Less(data[m], data[h]) {
+				i = h + 1
+			} else {
+				j = h
+			}
+		}
+		// Swap values until data[m] reaches the position i.
+		for k := m; k > i; k-- {
+			data[k], data[k-1] = data[k-1], data[k]
+		}
+		return
+	}
+
+	mid := int(uint(a+b) >> 1)
+	n := mid + m
+	var start, r int
+	if m > mid {
+		start = n - b
+		r = mid
+	} else {
+		start = a
+		r = m
+	}
+	p := n - 1
+
+	for start < r {
+		c := int(uint(start+r) >> 1)
+		if !cmp.Less(data[p-c], data[c]) {
+			start = c + 1
+		} else {
+			r = c
+		}
+	}
+
+	end := n - start
+	if start < m && m < end {
+		rotateOrdered(data, start, m, end)
+	}
+	if a < start && start < mid {
+		symMergeOrdered(data, a, start, mid)
+	}
+	if mid < end && end < b {
+		symMergeOrdered(data, mid, end, b)
+	}
+}
+
+// rotateOrdered rotates two consecutive blocks u = data[a:m] and v = data[m:b] in data:
+// Data of the form 'x u v y' is changed to 'x v u y'.
+// rotate performs at most b-a many calls to data.Swap,
+// and it assumes non-degenerate arguments: a < m && m < b.
+func rotateOrdered[E cmp.Ordered](data []E, a, m, b int) {
+	i := m - a
+	j := b - m
+
+	for i != j {
+		if i > j {
+			swapRangeOrdered(data, m-i, m, j)
+			i -= j
+		} else {
+			swapRangeOrdered(data, m-i, m+j-i, i)
+			j -= i
+		}
+	}
+	// i == j
+	swapRangeOrdered(data, m-i, m, i)
+}
